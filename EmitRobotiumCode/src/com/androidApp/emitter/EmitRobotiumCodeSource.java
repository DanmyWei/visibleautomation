package com.androidApp.emitter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Stack;

import com.androidApp.emitter.CodeDefinition;
import com.androidApp.emitter.IEmitCode.LineAndTokens;
import com.androidApp.emitter.TokenScanner.Predicate;
import com.androidApp.emitter.CodeDefinition.DialogScanType;
import com.androidApp.emitter.CodeDefinition.DialogTagType;
import com.androidApp.parser.ProjectPropertiesScan;
import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * @author Matthew
 * Copyright (c) 2013 Visible Automation LLC.  All Rights Reserved.
 * TODO: All Events MUST respect mLastEventWasWaitForActivity, not just click
 * TODO: add mLastEventWasCreateDialog for the same thing
 */
public class EmitRobotiumCodeSource implements IEmitCode {
	protected int 			mViewVariableIndex = 0;					// incremented for unique view variable names
	protected int 			mActivityVariableIndex = 0;				// incremented for unique activity variable names
	protected int 			mMotionEventVariableIndex = 0;			// incremented for unique motion event file names
	protected int			mFunctionNameIndex = 0;					// incremented for dialog and activity conditional fns
	protected String 		mTargetClassPath = null;				// class path of initial activity.	
	protected String 		mTargetPackage = null;					// package name that the recorder pulled from the app
	private boolean 		mLastEventWasWaitForActivity = false;	// want to do a waitForView for next event.
	private boolean			mLastEventWasWaitForDialog = false;		// want to do a waitForView for next event
	protected String 		mCurrentActivityName = null;			// current activity name (from activity transition)
	protected String 		mActivityVariable = null;				// variable name for this activity
	protected boolean 		mfActivityMatches = false;				// new activity has same name as current activity
	protected int			mStartInsertionPoint = 0;				// start insertion (for when we insert multichar)
	protected StringBuffer 	mCurrentText = new StringBuffer();		// for tracking text entry
	protected boolean		mfFirstKey = true;						// latch for text entry start
	protected static int	sLineNumber = 0;						// track line # throughout recursions
	protected String 		mNextLine;								// next line to save for caller.
	public EmitRobotiumCodeSource() {
	}	
		
	/**
	 * return the fully qualified class path of the application under test
	 * @return
	 */
	public String getApplicationClassPath() {
		return mTargetClassPath;
	}
	
	/**
	 * return the class name of the application under test
	 * @return
	 */
	public String getApplicationClassName() {
		if (mTargetClassPath != null) {
			return StringUtils.getNameFromClassPath(mTargetClassPath);
		} else {
			return null;
		}
	}
	
	/**
	 * return the package name of the application under test.
	 * @return
	 */
	public String getApplicationPackage() {
		return mTargetPackage;
	}
	
	
	/**
	 * take the events file name (which may be the reserved word "device", and emit the test code into
	 * an array list of the output code with its associated source tokens
	 * @param emitter the emitter
	 * @param eventsFileName source events file, or device if we pull it from the device.
	 * @return list of test code and source tokens.
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void generateTestCode(String 										eventsFileName, 
								 Hashtable<CodeDefinition, List<LineAndTokens>> outputCode,
								 List<MotionEventList> 							motionEvents) throws FileNotFoundException, IOException, EmitterException {
		InputStream is = new FileInputStream(eventsFileName);
		List<String> lines = FileUtility.readToLines(is);
		is.close();
		List<List<String>> tokenLines = tokenizeLines(lines);
		// because the output is written by multiple threads, it needs to be sorted by timestamp. The
		// dialog and popup output are written by a timer thread, which can interleave with the activity transition
		Collections.sort(tokenLines, new TimestampComparator());
		OrderByActivity orderByActivity = new OrderByActivity();
		List<List<String>> orderedTokenLines = orderByActivity.orderTokensByActivity(tokenLines);
		for (List<String> tokens : orderedTokenLines) {
			System.out.println(tokens.toString());
		}
		scanTargetPackage(orderedTokenLines);
		CodeOutput mainLines = emit(orderedTokenLines, 0, outputCode, motionEvents, OutputType.MAIN);
		outputCode.put(new CodeDefinition(Constants.MAIN, null), mainLines.mLineAndTokens);
	}

	/**
	 * scan for the target package token (3rd token in package:237353376,com.skype.raider)
	 * @param lines
	 * @return
	 */
	public boolean scanTargetPackage(List<List<String>> lines) {
		for (List<String> tokens : lines) {
			String action = tokens.get(0);
			if (Constants.ActivityEvent.PACKAGE.equals(action)) {
				mTargetPackage = tokens.get(2);
				return true;
			}
		}
		return false;
	}
	
	// pre-tokenize the lines
	
	public static List<List<String>> tokenizeLines(List<String> lines) {
		List<List<String>> tokenLines = new ArrayList<List<String>>();
		for (String line : lines) {
			SuperTokenizer st = new SuperTokenizer(line, "\"", ":,", '\\');
			tokenLines.add(st.toList());
		}
		return tokenLines;
	}
	
	/**
	 * the timestamp is the second element in each token list. sort by it
	 * @author matt2
	 *
	 */

	protected class TimestampComparator implements Comparator {

		@Override
		public int compare(Object arg0, Object arg1) {
			List<String> tokens0 = (List<String>) arg0;
			List<String> tokens1 = (List<String>) arg1;
			long timestamp0 = Long.parseLong(tokens0.get(2));
			long timestamp1 = Long.parseLong(tokens1.get(2));
			return (int) (timestamp0 - timestamp1);
		}		
	}
	
	/**
	 * actually emit robotium code from a recorded file
	 * TODO: change this so it returns the target class path and class name, not modifying statics
	 * @param tokenLines vector of parsed lines read from events.txt
	 * @param startReadIndex starting index
	 * @param outputCode code output and last read index (for recursion into conditional/interstitials)
	 * @param motionEvents motion events parsed 
	 * @param outputType controls termination for main or interstitial runs
	 * @throws IOException
	 * @throws EmitterException
	 */
	@Override
	public CodeOutput emit(List<List<String>>								tokenLines,
							int												startReadIndex,
							Hashtable<CodeDefinition, List<LineAndTokens>>	outputCode,
							List<MotionEventList> 							motionEvents,
							OutputType										outputType) throws IOException, EmitterException {
		boolean scrollsHaveHappened = false;							// we get a zillion scroll events.  We only care about the last one
		int scrollFirstVisibleItem = 0;									// preserve scroll values so we can apply it on the last scroll.
		int scrollListIndex = 0;										// track the current scroll index to write on the next non-scroll instruction
		ReferenceParser scrollListRef = null;							// track the current scroll reference to write on the next non-scroll instruction
		List<String> clickSpinnerDialogTokens = null;					// workaround for robotium, which selects spinners, but doesn't just click-dismiss
		List<LineAndTokens> lines = new ArrayList<LineAndTokens>();		// output code for this scope
		Stack<String> activityStack = new Stack<String>();
		TokenScanner tokenScanner = new TokenScanner();					// for predicate test against read lines
		int readIndex;
		for (readIndex = startReadIndex; readIndex < tokenLines.size(); readIndex++) {
			List<String> tokens = tokenLines.get(readIndex);
			try {
				
				// we peek at the next line to see if it's an activity_forward or an activity back, and save the activity name so it can be 
				// waited for.
				List<String> nextTokens = null;
				if (readIndex < tokenLines.size() - 1) {
					nextTokens = tokenLines.get(readIndex + 1);
					checkActivityTransition(tokens, nextTokens, lines);
				}
				String action = tokens.get(0);
				
				// when the recorder scrolls, it writes out a scroll message for each move, but
				// we just want robotium to issue a single scroll command, so once we read a scroll
				// command, we wait until a scroll happens on another listview, or a different event
				// has occurred, and we scroll to the last list item that was recorded.
				if (scrollsHaveHappened) {
					if (!Constants.UserEvent.SCROLL.equals(action)) {
						writeScroll(scrollListRef, scrollFirstVisibleItem, tokens, lines);
						scrollsHaveHappened = false;
					} else {
						// scroll:195758909,0,11,11,class_index,android.widget.ListView,1
						// command:time,firstVisible,visibleItemCount,totalItemCount,[view reference]
						ReferenceParser scrollListRefTest = new ReferenceParser(tokens, 5);
						if (!scrollListRefTest.equals(scrollListRef)) {
							writeScroll(scrollListRef, scrollFirstVisibleItem, tokens, lines);
							scrollsHaveHappened = false;
						}
					}
				}	
				
				// see if there's conditional code that matches this activity or dialog
				
				CodeDefinition codeDef = findConditionalCode(tokens, outputCode);
				if (codeDef != null) {
					List<LineAndTokens> conditionalCode = outputCode.get(codeDef);
					lines.addAll(conditionalCode);
					if (codeDef.getType() == CodeDefinition.Type.ACTIVITY) {
						readIndex = findClosingActivity(tokenLines, tokenScanner, codeDef, readIndex);
						continue;
					} else if (codeDef.getType() == CodeDefinition.Type.DIALOG){
						readIndex = findDialogClose(tokenLines, tokenScanner, codeDef, readIndex);
					}
				}
				
				// then everything else is switched on the event name.
				if (Constants.ActivityEvent.INTERSTITIAL_ACTIVITY.equals(action)) {
					String newActivityName = tokens.get(2);
					CodeOutput activityCode = handleInterstitialActivity(tokenLines, tokenScanner, readIndex, outputCode, motionEvents, tokens);
					lines.addAll(activityCode.mLineAndTokens);
					readIndex = activityCode.mNextLineIndex - 1; 	// loop increments this
				} else if (Constants.UserEvent.isInterstitialDialogEvent(action)) {
					CodeOutput dialogCode = handleInterstitialDialog(tokenLines, tokenScanner, readIndex, outputCode, motionEvents, tokens);
					lines.addAll(dialogCode.mLineAndTokens);
					readIndex = dialogCode.mNextLineIndex - 1;	// loop increments this
				} else if (Constants.ActivityEvent.ACTIVITY_FORWARD.equals(action)) {
					String activityClass = tokens.get(2);
					activityStack.push(activityClass);
					
					// if this is the first activity_forward, then record the classpath so we can construct the output project
					if (mTargetClassPath == null) {
						mTargetClassPath = tokens.get(2);
					}
					mLastEventWasWaitForActivity = true;
					// if there is no user event between this and the next activity, then don't write the waitForActivity()
					// call, because this is based on a timer or network request, and we shouldn't bother waiting for 
					// activities that the user isn't going to interact with. What we do next depends on if we 
					// do activity_forward or go_back next.  If it's activity_forward, we skip to it, if it's
					// activit_back, we skip over it.
					
					boolean fUserInteraction = TokenScanner.happensBefore(tokenLines, readIndex + 1, 
																	   	  tokenScanner.new UserEventPredicate(), 
																	   	  tokenScanner.new ActivityTransitionPredicate());
					if (!fUserInteraction) {
						int goBackIndex = TokenScanner.scanForward(tokenLines, readIndex + 1, 
												   				  tokenScanner.new EventListPredicate(Constants.ActivityEvent.ACTIVITY_BACK.mEventName));
						int goForwardIndex = TokenScanner.scanForward(tokenLines, readIndex + 1, 
																	  tokenScanner.new EventListPredicate(Constants.ActivityEvent.ACTIVITY_FORWARD.mEventName));
						// don't forget that next iteration skips
						if ((goBackIndex != -1) && (goBackIndex < goForwardIndex)) {
							readIndex = goBackIndex;
						} else if (goForwardIndex != -1) {
							readIndex = goForwardIndex - 1;
						}

					} else {
						boolean fInterstitialActivityMatch = TokenScanner.happensBefore(tokenLines, readIndex + 1,
																						tokenScanner.new EventParameterPredicate(Constants.ActivityEvent.INTERSTITIAL_ACTIVITY.mEventName, 2, activityClass),
																					    tokenScanner.new ActivityTransitionPredicate());
						// if an interstitial activity (with the same activity name)was marked after this activity_forward 
						// transition, and there is no activity transition, between us, then DO NOT write the waitActivity() 
						// call, because it should be taken care of by the condition.
						if (!fInterstitialActivityMatch) {
							// applications can use the same activity class with different contents in the intent, so we have to
							// write different "wait" cases.
							if (mfActivityMatches) {
								writeWaitForMatchingActivity(mActivityVariable, tokens, lines);
							} else {
								writeWaitForActivity(tokens, lines);
							}
						}
					}
					
					// if we're in an interstitial, that means that it's time to go, but don't forget to add the next wait for activity call
					if ((outputType == OutputType.INTERSTITIAL_ACTIVITY) || (outputType == OutputType.INTERSTITIAL_DIALOG)) {
						return new CodeOutput(lines, readIndex + 1);
					}
				} else if (Constants.ActivityEvent.ACTIVITY_BACK.equals(action) || Constants.UserEvent.ACTIVITY_BACK_KEY.equals(action)) {
					if (!activityStack.isEmpty()) {
						activityStack.pop();
					}

					if (Constants.UserEvent.ACTIVITY_BACK_KEY.equals(action)) {
						// I think this is technically incorrect, since the "back" event doesn't always happen from the back key
						// but some other event like a click, and we should use a different template
						if ((tokens.size() > 2) && mfActivityMatches) {
							writeGoBackToMatchingActivity(mActivityVariable, tokens, lines);
						} else {
							writeGoBackAndWaitForActivity(tokens, lines);
						}
						mLastEventWasWaitForActivity = true;
						
						// the handler is responsible for managing the activity transition, so the back event is part of it
						if ((outputType == OutputType.INTERSTITIAL_ACTIVITY) || (outputType == OutputType.INTERSTITIAL_DIALOG)) {
							return new CodeOutput(lines, readIndex + 1);
						}
					}
				} else {
					if (Constants.UserEvent.ITEM_CLICK.equals(action)) {
						writeItemClick(tokens, lines);
					} else if (Constants.UserEvent.ITEM_SELECTED.equals(action)) {
						writeItemClick(tokens, lines);
					} else if (Constants.UserEvent.ITEM_CLICK_BY_TEXT.equals(action)) {
						writeItemClickByText(tokens, lines);
					} else if (Constants.UserEvent.POPUP_MENU_ITEM_CLICK.equals(action)) {
						writePopupMenuItemClick(tokens, lines);
					} else if (Constants.UserEvent.SPINNER_ITEM_SELECTED.equals(action)) {
						writeSpinnerItemSelected(tokens, lines);
					} else if (Constants.UserEvent.GROUP_CLICK.equals(action)) {
						writeGroupClick(tokens, lines);
					} else if (Constants.UserEvent.CHILD_CLICK.equals(action)) {
						writeChildClick(tokens, lines);
					} else if (Constants.UserEvent.SCROLL.equals(action)) {
						scrollFirstVisibleItem = Integer.parseInt(tokens.get(2));
						scrollsHaveHappened = true;
						scrollListRef = new ReferenceParser(tokens, 5);
					} else if (Constants.UserEvent.CLICK.equals(action)) {
						writeClick(tokens, lines);
					} else if (Constants.UserEvent.CLICK_WORKAROUND.equals(action)) {
						writeClickWorkaround(tokens, lines);
					} else if (Constants.SystemEvent.DISMISS_DIALOG.equals(action)) {
						mLastEventWasWaitForDialog = true;
						writeDismissDialog(tokens, lines);
						if (outputType == OutputType.INTERSTITIAL_DIALOG) {
							return new CodeOutput(lines, readIndex + 1);
						}
					} else if (Constants.UserEvent.CANCEL_DIALOG.equals(action)) {
						mLastEventWasWaitForDialog = true;
						writeCancelDialog(tokens, lines);
						if (outputType == OutputType.INTERSTITIAL_DIALOG) {
							return new CodeOutput(lines, readIndex + 1);
						}
					} else if (Constants.SystemEvent.CREATE_DIALOG.equals(action)) {
						// if the dialog doesn't have any interaction from the user before it disappears, it's a 
						// progress dialog, so we have to write it as conditional, rather than assert its existence,
						// because it may disappear faster than waitForDialog() can pick it up.
						if (TokenScanner.happensBefore(tokenLines, readIndex + 1, 
													   tokenScanner.new EventListPredicate(Constants.SystemEvent.DISMISS_DIALOG.mEventName),
													   tokenScanner.new UserEventPredicate())) {
							readIndex = writeConditionalDialog(tokenLines, tokenScanner, readIndex, outputCode, motionEvents, tokens, lines);
						} else if (!TokenScanner.happensBefore(tokenLines, readIndex, tokenScanner.new InterstitialDialogPredicate(), tokenScanner.new DialogClosePredicate())) {
							// when we do the interstitial dialog marker, it happens after the create dialog call
							// if there is an interstitial dialog marker before the dialog close, then it will write the 
							// dialog condition code, and we don't want to do a waitForDialogToOpen() here
							writeCreateDialog(tokens, lines);
							mLastEventWasWaitForDialog = true;
						}
					} else if (Constants.SystemEvent.SHOW_IME.equals(action)) {
						writeShowIME(tokens, lines);
					} else if (Constants.UserEvent.HIDE_IME_BACK_KEY.equals(action)) {
						
						// always hide on the back key
						writeHideIME(tokens, lines);
					} else if (Constants.SystemEvent.HIDE_IME.equals(action)) {
						// only write out the hide IME if a user event happens before a dialog close or activity transition.
						TokenScanner.Predicate transitionPredicate = tokenScanner.new OrPredicate(tokenScanner.new DialogClosePredicate(),
																								  tokenScanner.new ActivityTransitionPredicate());
						if (TokenScanner.happensBefore(tokenLines, readIndex, tokenScanner.new UserEventPredicate(), transitionPredicate)) {
							writeHideIME(tokens, lines);
						}
					} else if (Constants.UserEvent.BEFORE_TEXT.equals(action) || 
							   Constants.UserEvent.BEFORE_TEXT_KEY.equals(action)) {
						if (mCurrentText.length() == 0) {
							mStartInsertionPoint = Integer.parseInt(tokens.get(3));
						}
					} else if (Constants.UserEvent.AFTER_TEXT_KEY.equals(action)) {
						if (!addChangeToCurrentText(tokens, lines)) {			
							String nextAction = nextTokens.get(0);
							// if the next event isn't a before_text_key event, and it's some kind of other user event,
							// then spit out the text.  We don't spit in all cases, because a system event (like an
							// autocorrect dropdown appearing/disappearing might happen, and it doesn't affect text entry)
							if (!Constants.UserEvent.BEFORE_TEXT_KEY.equals(nextAction) && (mCurrentText.length() > 0)) {
								writeEnterTextByKey(tokens, lines, mStartInsertionPoint, mCurrentText.toString());
								mCurrentText = new StringBuffer();
							}
						}
					} else if (Constants.UserEvent.AFTER_TEXT.equals(action)) {
						// if the next event isn't "before_text", then spit out the text in a solo.enterText() call
						String nextAction = nextTokens.get(0);
						if (!Constants.UserEvent.BEFORE_TEXT.equals(nextAction)) {
							writeEnterText(tokens, lines);
						}	
					} else if (Constants.SystemEvent.AFTER_SET_TEXT.equals(action)) {
						if (TokenScanner.happensBefore(tokenLines, readIndex, tokenScanner.new UserEventPredicate(), tokenScanner.new ActivityTransitionPredicate())) {
							writeWaitForText(tokens, lines);
						}
					} else if (Constants.UserEvent.GET_FOCUS.equals(action)) {
						writeGetFocus(tokens, lines);
					} else if (Constants.SystemEvent.DISMISS_AUTOCOMPLETE_DROPDOWN.equals(action)) {
						writeDismissAutoCompleteDropdown(tokens, lines);
					} else if (Constants.UserEvent.DISMISS_POPUP_WINDOW_BACK_KEY.equals(action)) {
						writeDismissPopupWindowBackKey(tokens, lines);
					} else if (Constants.SystemEvent.CREATE_SPINNER_POPUP_DIALOG.equals(action)) {
						clickSpinnerDialogTokens = tokens;
					} else if (Constants.UserEvent.DISMISS_SPINNER_DIALOG_BACK_KEY.equals(action)) {
						if (clickSpinnerDialogTokens == null) {
							writeException(tokens, "spinner dialog was dismissed, but not created", lines);
						} else {
							writeClick(clickSpinnerDialogTokens, lines);
							writeGoBack(tokens, lines);
							writeDismissDialog(tokens,lines);
						}
					} else if (Constants.UserEvent.DISMISS_SPINNER_POPUP_BACK_KEY.equals(action)) {
						writeClick(tokens, lines);
						writeDismissPopupWindowBackKey(tokens, lines);
					} else if (Constants.SystemEvent.ROTATION.equals(action)) {
						writeRotation(tokens, lines);
					} else if (Constants.UserEvent.MENU_ITEM_CLICK.equals(action)) {
						writeMenuItemClick(tokens, lines);
					} else if (Constants.SystemEvent.EXCEPTION.equals(action)) {
						writeException(tokens, lines);
					} else if (Constants.UserEvent.SELECT_ACTIONBAR_TAB.equals(action)) {
						selectActionBarTab(tokens, lines);
					} else if (Constants.UserEvent.SELECT_TAB.equals(action)) {
						selectTab(tokens, lines);
					} else if (Constants.UserEvent.PAGE_SELECTED.equals(action)) {
						pageSelected(tokens, lines);
					} else if (Constants.SystemEvent.ON_PAGE_FINISHED.equals(action)) {
						// TODO: TEMPORARY for DEMO.. for some reason in the cozi app, the recorder picks up 2 webviews
						// but the playback runtime only recognizes one.
						// waitForPageToLoad(tokens, lines);
					} else if (Constants.UserEvent.TOUCH_DOWN.equals(action) || Constants.UserEvent.TOUCH_MOVE.equals(action)) {
						// we have to listen for the first "touch move", not just touch down, because scroll containers
						// don't actually fire the TouchEvent listener for TOUCH_DOWN because it dispatches the event
						// to a child object, and does not call View.dispatchTouchEvent() for the scrolling view.
						// there may be a way around this
						// note that we increment readIndex in the loop, so we -1 it
						readIndex = writeMotionEvents(tokenLines, readIndex, getApplicationClassName(), motionEvents, lines) - 1;
					} else if (Constants.UserEvent.COPY_TEXT.equals(action)) {
						copyText(tokens, lines);
					}
				}
			} catch (Exception ex) {
				System.err.println("error parsing line " + startReadIndex);
				System.err.println("line = " + tokenLines.get(startReadIndex));
				ex.printStackTrace();
				System.exit(-1);
			}
		} 
		return new CodeOutput(lines, readIndex);
	}
	
	public CodeOutput handleInterstitialActivity(List<List<String>>								tokenLines,
												 TokenScanner									tokenScanner,
												 int											currentReadIndex,
												 Hashtable<CodeDefinition, List<LineAndTokens>> outputCode,
												 List<MotionEventList> 							motionEvents,
												 List<String> 									tokens) throws EmitterException, IOException {
		return handleInterstitialActivity(tokenLines, tokenScanner, currentReadIndex, outputCode, motionEvents, tokens, Constants.Templates.ACTIVITY_FUNCTION);
	}
	/**
	 * write out the if (waitForActivity()) { interstitial_code } in the main code, and the handler function in the
	 * handler set
	 * @param tokenLines
	 * @param currentReadIndex
	 * @param outputCode
	 * @param motionEvents
	 * @param tokens
	 * @return
	 * @throws EmitterException
	 * @throws IOException
	 */
	public CodeOutput handleInterstitialActivity(List<List<String>>								tokenLines,
												 TokenScanner									tokenScanner,
												 int											currentReadIndex,
												 Hashtable<CodeDefinition, List<LineAndTokens>> outputCode,
												 List<MotionEventList> 							motionEvents,
												 List<String> 									tokens,
												 String											functionTemplateName) throws EmitterException, IOException {
		String newActivityName = tokens.get(2);
		// We don't just want the previous line, we want the activity transition or user event prior to the 
		// activity_forward that this interstitial activity was launched in, so we scan backwards to the first activity transition to a different activity
		TokenScanner.Predicate causingPredicate = tokenScanner.new OrPredicate(tokenScanner.new PredicateParameter(tokenScanner.new ActivityTransitionPredicate(), 
																												   2, newActivityName, false),
																			   tokenScanner.new UserEventPredicate());
		int causingLineIndex = TokenScanner.findPrevious(tokenLines, currentReadIndex, causingPredicate);
		CodeDefinition codeDef;
		if (causingLineIndex == -1) {
			TokenScanner.Predicate previousActivityPredicate = tokenScanner.new ActivityTransitionPredicate();
			int previousActivityIndex = TokenScanner.findPrevious(tokenLines, currentReadIndex, previousActivityPredicate);
			if (previousActivityIndex != -1) {
				List<String> precedingTokens = tokenLines.get(previousActivityIndex);
				codeDef = new CodeDefinition(newActivityName, precedingTokens);
			} else {
				List<String> precedingTokens = tokenLines.get(0);
				codeDef = new CodeDefinition(newActivityName, precedingTokens);
			}		
		} else {
			List<String> precedingTokens = tokenLines.get(causingLineIndex);
			codeDef = new CodeDefinition(newActivityName, precedingTokens);
		}
		CodeOutput activityOutput = emit(tokenLines, currentReadIndex + 1, outputCode, motionEvents, OutputType.INTERSTITIAL_ACTIVITY);
		String functionName = addLinesAsFunction(tokens, newActivityName, activityOutput.mLineAndTokens, functionTemplateName, outputCode);
		List<LineAndTokens> activityLines = new ArrayList<LineAndTokens>();
		LineAndTokens conditionalCode = activityCondition(tokens, newActivityName, functionName);
		activityLines.add(conditionalCode);
		outputCode.put(codeDef, activityLines);
		activityOutput.mLineAndTokens = activityLines;
		return activityOutput;
	}

	/**
	 * actual code insert for the activity condition
	 * @param tokens
	 * @param activityName
	 * @param functionName
	 * @return
	 * @throws IOException
	 */
	public LineAndTokens activityCondition(List<String> tokens, String activityName, String functionName) throws IOException {
		String activityConditionTemplate = FileUtility.readTemplate(Constants.Templates.ACTIVITY_CONDITION);
		String description = "wait to see if activity " + activityName + " has appeared";
		activityConditionTemplate = activityConditionTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, activityName);
		activityConditionTemplate = activityConditionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		activityConditionTemplate = activityConditionTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		activityConditionTemplate = activityConditionTemplate.replace(Constants.VariableNames.FUNCTION_NAME, functionName);
		return new LineAndTokens(tokens, activityConditionTemplate);
	}

   /**
    * TODO: for some reason, this code output is getting doubled.
	 * consolidated code to handle interstitial dialogs
	 * @param br for reading /sdcard/events.txt into tokens
	 * @param previousLine we write this into the file to test against for when we insert the conditional code again
	 * @param outputCode outputcode hashtable
	 * @param motionEvents passed in recursive call to emit
	 * @param tokens tokens containing the interstitial request
	 * @return emitted code.
	 * @throws EmitterException
	 * @throws IOException
	 */
	public CodeOutput handleInterstitialDialog(List<List<String>>								tokenLines,
											   TokenScanner										tokenScanner,
												int												currentReadIndex,
												Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode,
												List<MotionEventList> 							motionEvents,
												List<String> 									tokens) throws EmitterException, IOException {
		String action = tokens.get(0);
		// We don't just want the previous line, we want the activity transition or user event prior to the 
		// activity_forward that this interstitial dialog was launched in.
		TokenScanner.Predicate causingPredicate = tokenScanner.new OrPredicate(tokenScanner.new ActivityTransitionPredicate(), 
																			   tokenScanner.new UserEventPredicate());
		int causingLineIndex = tokenScanner.findPrevious(tokenLines, currentReadIndex, causingPredicate);
		List<String> precedingTokens = tokenLines.get(causingLineIndex);
		
		CodeDefinition codeDef = null;
		String activityName = tokens.get(2);
		if (Constants.UserEvent.INTERSTITIAL_DIALOG_CONTENTS_ID.equals(action)) {
			// interstitial_dialog_contents_id:123627258,com.example.android.apis.app.AlertDialogSamples,com.example.foo.R.string.bar
			String id = tokens.get(3);
			codeDef = new CodeDefinition(activityName, id, CodeDefinition.DialogScanType.CONTENT,
				    					CodeDefinition.DialogTagType.ID, precedingTokens);
		} else if (Constants.UserEvent.INTERSTITIAL_DIALOG_CONTENTS_TEXT.equals(action)) {
			// interstitial_dialog_contents_text:123627258,com.example.android.apis.app.AlertDialogSamples,"Command two"
			String unescapedTag = StringUtils.unescapeString(StringUtils.stripQuotes(tokens.get(3)), '\\');
			codeDef = new CodeDefinition(activityName, unescapedTag, CodeDefinition.DialogScanType.CONTENT,
										 CodeDefinition.DialogTagType.TEXT, precedingTokens);
		} else if (Constants.UserEvent.INTERSTITIAL_DIALOG_TITLE_ID.equals(action)) {
			String id = tokens.get(3);
			codeDef = new CodeDefinition(activityName, id, CodeDefinition.DialogScanType.TITLE,
										 CodeDefinition.DialogTagType.ID, precedingTokens);
		} else if (Constants.UserEvent.INTERSTITIAL_DIALOG_TITLE_TEXT.equals(action)) {
			// interstitial_dialog_title_text:123609633,com.example.android.apis.app.AlertDialogSamples,"Header title"
			String unescapedTag = StringUtils.unescapeString(StringUtils.stripQuotes(tokens.get(3)), '\\');
			codeDef = new CodeDefinition(activityName, unescapedTag, CodeDefinition.DialogScanType.TITLE,
				    					 CodeDefinition.DialogTagType.TEXT, precedingTokens);
		}
		CodeOutput codeOutput = emit(tokenLines, currentReadIndex + 1, outputCode, motionEvents, OutputType.INTERSTITIAL_DIALOG);
		// we write the dialog lines at the end of the file, because of variable scoping issues
		String functionName = addLinesAsFunction(tokens, activityName, codeOutput.mLineAndTokens, Constants.Templates.DIALOG_FUNCTION, outputCode);
		List<LineAndTokens> dialogLines = new ArrayList<LineAndTokens>();
		LineAndTokens conditionalCode = dialogCondition(tokens, codeDef, functionName);
		dialogLines.add(conditionalCode);
		outputCode.put(codeDef, dialogLines);
		codeOutput.mLineAndTokens = dialogLines;
		return codeOutput;
	}
	
	/**
	 * write a dialog in the form if (waitForDialogToOpen(..)) { ...code ... }
	 * @param tokenLines
	 * @param tokenScanner
	 * @param currentReadIndex
	 * @param outputCode
	 * @param motionEvents
	 * @param tokens
	 * @param lines
	 * @return index of next line to read
	 * @throws EmitterException
	 * @throws IOException
	 */
	public int writeConditionalDialog(List<List<String>>								tokenLines,
								       TokenScanner										tokenScanner,
									   int												currentReadIndex,
									   Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode,
									   List<MotionEventList> 							motionEvents,
									   List<String> 									tokens,
									   List<LineAndTokens>								lines) throws EmitterException, IOException {
		writeConditionalCreateDialog(tokenLines.get(currentReadIndex), lines);
		CodeOutput codeOutput = emit(tokenLines, currentReadIndex + 1, outputCode, motionEvents, OutputType.INTERSTITIAL_DIALOG);
		lines.addAll(codeOutput.mLineAndTokens);
		lines.add(closeCondition(tokens));
		return codeOutput.mNextLineIndex;
	}
	

	/**
	 * 
	 * @param tokens
	 * @param activityName
	 * @param lines
	 * @param functionTemplateName
	 * @param outputCode
	 * @return the name of the function
	 * @throws IOException
	 */
	public String addLinesAsFunction(List<String> 									tokens, 
								   String 											activityName, 
								   List<LineAndTokens> 								lines, 
								   String											functionTemplateName,
								   Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode) throws IOException {
		ArrayList<LineAndTokens> copyLine = new ArrayList<LineAndTokens>(lines);
		String functionTemplate = FileUtility.readTemplate(functionTemplateName);
		
		// remove.the.dots.from.the.activity.class
		String functionName = StringUtils.getNameFromClassPath(activityName) + Integer.toString(mFunctionNameIndex);
		mFunctionNameIndex++;
		functionTemplate = functionTemplate.replace(Constants.VariableNames.FUNCTION_NAME, functionName);
		copyLine.add(0, new LineAndTokens(tokens, functionTemplate));
		copyLine.add(closeCondition(tokens));
		CodeDefinition functionCodeDef = new CodeDefinition(Constants.FUNCTIONS, null);
		List<LineAndTokens> functionCode = outputCode.get(functionCodeDef);
		if (functionCode == null) {
			outputCode.put(functionCodeDef, copyLine);
		} else {
			functionCode.addAll(copyLine);
		}
		return functionName;
	}
	
	/**
	 * write out the conditional test for a dialog.
	 * @param tokens
	 * @param codeDef
	 * @return
	 * @throws IOException
	 */
	public LineAndTokens dialogCondition(List<String> tokens, CodeDefinition codeDef, String functionName) throws IOException {
		String dialogConditionTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_CONDITION);
		String description = "wait to see if a dialog with string " + codeDef.getDialogTag() + " has appeared";
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.FUNCTION_NAME, functionName);
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.CODE_DEFINITION, codeDef.toCode());
		mActivityVariableIndex++;
		return new LineAndTokens(tokens, dialogConditionTemplate);
	}
	
	LineAndTokens closeCondition(List<String> tokens) {
		return new LineAndTokens(tokens, "}\n");
	}

	/**
	 * for an activity forward or activity back
	 * member variables: set mCurrentActivityName if the event was activity_forward
	 * mfActivityMatches: there was an activity transition, and the activity transitioned to has the same name
	 * mActivityVariable: variable name assigned to the activity transitioned to.
	 * @param tokens tokens for the current line
	 * @param nextTokens tokens for the lookahead next line
	 * @param lines output if we record an activity transition.
	 * @return true if there was an activity transition
	 */
	protected boolean checkActivityTransition(List<String> tokens, List<String> nextTokens, List<LineAndTokens> lines) throws IOException {
		// if it's the first "", then it's the class
		if (Constants.ActivityEvent.ACTIVITY_FORWARD.equals(tokens.get(0))) {
			if (mTargetClassPath == null) {
				mTargetClassPath =  tokens.get(2);
				mCurrentActivityName = tokens.get(2);
			}
		}
		if (nextTokens.size() > 2) {
			String nextAction = nextTokens.get(0);
			if (Constants.ActivityEvent.ACTIVITY_FORWARD.equals(nextAction) || 
			    Constants.ActivityEvent.ACTIVITY_BACK.equals(nextAction) || 
			    Constants.UserEvent.ACTIVITY_BACK_KEY.equals(nextAction)) {
				String nextActivityName = nextTokens.get(2);
				mfActivityMatches = nextActivityName.equals(mCurrentActivityName);
				if (mfActivityMatches) {
					mActivityVariable = writeGetCurrentActivity(tokens, lines);
				}
				mCurrentActivityName = nextActivityName;
				return true;
			} 
		}
		return false;
	}

	
	/**
	 * the description is written as the last token
	 * @param lines
	 */
	public String getDescription(List<String> tokens) {
		return tokens.get(tokens.size() - 1);
	}
	
	/**
	 * write the test function header
	 * @param bw output writer
	 * @throws IOException if the function header template can't be read
	 */
	public void writeFunctionHeader(BufferedWriter bw) throws IOException {
		String testFunction = FileUtility.readTemplate(Constants.Templates.TEST_FUNCTION);
		bw.write(testFunction);
	}
	
	public void writeException(List<String> tokens, String description, List<LineAndTokens> lines) throws IOException {
		String exceptionTemplate = FileUtility.readTemplate(Constants.Templates.EXCEPTION);
		exceptionTemplate = exceptionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		lines.add(new LineAndTokens(tokens, exceptionTemplate));				
	}
	/**
	 * write the exception and its description
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeException(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String exceptionTemplate = FileUtility.readTemplate(Constants.Templates.EXCEPTION);
		String description = tokens.get(2);
		exceptionTemplate = exceptionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		lines.add(new LineAndTokens(tokens, exceptionTemplate));				
	}
	
	/**
	 * write the select action bar event select_actionbar_tab:90167820,0,Select tab earth
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void selectActionBarTab(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String selectActionBarTabTemplate = FileUtility.readTemplate(Constants.Templates.SELECT_ACTIONBAR_TAB);
		String tabIndex = tokens.get(2);
		String description = tokens.get(3);
		selectActionBarTabTemplate = selectActionBarTabTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		selectActionBarTabTemplate = selectActionBarTabTemplate.replace(Constants.VariableNames.TAB_INDEX, tabIndex);
		lines.add(new LineAndTokens(tokens, selectActionBarTabTemplate));
	}
	/**
	 * write the select tab event select_tab:88338018,id,0x1020012,android.widget.TabHost,tab3
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void selectTab(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String description = "select tab";
		String selectTabTemplate = "";
		String tabId = tokens.get(5);
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		// NOTE: need to search resource files for the tab id's
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			selectTabTemplate = writeViewIDCommand(Constants.Templates.SELECT_TAB_ID, ref, description);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			selectTabTemplate = writeViewClassIndexCommand(Constants.Templates.SELECT_TAB_CLASS_INDEX, ref, description);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			selectTabTemplate = writeViewInternalClassIndexCommand(Constants.Templates.SELECT_TAB_INTERNAL_CLASS_INDEX, ref, description);
		}
		selectTabTemplate = selectTabTemplate.replace(Constants.VariableNames.TAB_ID, tabId);
		lines.add(new LineAndTokens(tokens, selectTabTemplate));
	}
	//				String logMsg = Integer.toString(state) + "," + getDescription(mViewPager);

	/**
	 * write the page selected event: page_selected:88338018,id,0x1020012,1,pager
	 * @param tokens tokenized input line
	 * @param lines output code
	 * @throws IOException
	 */
	public void pageSelected(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String description = "page selected";
		String pageSelectedTemplate = "";
		String tabId = tokens.get(5);
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		// NOTE: need to search resource files for the tab id's
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			pageSelectedTemplate = writeViewIDCommand(Constants.Templates.PAGE_SELECTED_ID, ref, description);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			pageSelectedTemplate = writeViewClassIndexCommand(Constants.Templates.PAGE_SELECTED_CLASS_INDEX, ref, description);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			pageSelectedTemplate = writeViewInternalClassIndexCommand(Constants.Templates.PAGE_SELECTED_INTERNAL_CLASS_INDEX, ref, description);
		}
		pageSelectedTemplate = pageSelectedTemplate.replace(Constants.VariableNames.PAGE_ID, tabId);
		lines.add(new LineAndTokens(tokens, pageSelectedTemplate));
	}
	

	/**
	 * write the invokeMenuActionSync() call
	 * @param tokens
	 * @param startIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String menuItemClickTemplate = FileUtility.readTemplate(Constants.Templates.MENU_ITEM_CLICK);
		String menuItemId = tokens.get(2);
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.MENU_ITEM_ID, menuItemId);
		mViewVariableIndex++;
		lines.add(new LineAndTokens(tokens, menuItemClickTemplate));				
	}

	/**
	 * write the getCurrentActivity() call
	 * @param lines
	 * @throws IOException
	 */
	public String writeGetCurrentActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String getCurrentActivityTemplate = FileUtility.readTemplate(Constants.Templates.GET_CURRENT_ACTIVITY);
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.DESCRIPTION, "get the current activity, since the next one has the same class name");
		lines.add(new LineAndTokens(null, getCurrentActivityTemplate));
		String activityName = Constants.Names.ACTIVITY + Integer.toString(mActivityVariableIndex);
		return activityName;
	}
	
	/**
	 * when we send an event to a view just after we do waitForActivity(), some applications (like ApiDemos) use the same activity
	 * with different contents, so it returns immediately, even though the new screen is up.  If there's just been a waitForActivity(), 
	 * then the next view-based event should do a waitForView(), to make sure that the view's actually been shown.
	 * @param tokens parsed from a line in events.txt
	 * @param startIndex starting index of the view reference
	 * @param lines output list of java instructions
	 * 
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForView(List<String> tokens, int startIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, startIndex);
		String description = getDescription(tokens);
		String fullDescription = "wait for view " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String waitForViewTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String waitForClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForClassIndexTemplate));			
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String waitForInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_VIEW_INTERNAL_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForInternalClassIndexTemplate));			
		}
		mViewVariableIndex++;
	}
	
	
	/**
	 * the application has finished an activity, or set of activities, so we just need to wait for the activity.
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the solo.goBack() call
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBack(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
		lines.add(new LineAndTokens(tokens, goBackTemplate));			
	}
	
	/**
	 * write the solo.goBack() call
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackAndWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		if (tokens.size() > 2) {
			String classPath = tokens.get(2);
			String description = getDescription(tokens);
			String fullDescription = "wait for activity " + description;
			String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK_WAIT_ACTIVITY);
			goBackTemplate = goBackTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
			goBackTemplate = goBackTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
			lines.add(new LineAndTokens(tokens, goBackTemplate));
		} else {
			String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
			lines.add(new LineAndTokens(tokens, goBackTemplate));			
		}
	}

	/**
	 * solo.waitForActivity() when we go forward or back to an activity
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * when we go forward to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeWaitForMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_NEW_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the expression for waitForDialogToClose
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeDismissDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCloseTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_CLOSE_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "dismiss dialog " + description;
		waitForDialogCloseTemplate = waitForDialogCloseTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCloseTemplate));
	}
	/**
	 * write the expression for goBack() for a dialog
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeCancelDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCancelTemplate = FileUtility.readTemplate(Constants.Templates.CANCEL_DIALOG_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "cancel dialog " + description;
		waitForDialogCancelTemplate = waitForDialogCancelTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCancelTemplate));
	}
	
	/**
	 * wait for dialogs to be created before interacting with them
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeCreateDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCreateTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_DIALOG_TO_OPEN);
		String description = getDescription(tokens);
		String fullDescription = "create dialog " + description;
		waitForDialogCreateTemplate = waitForDialogCreateTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCreateTemplate));
	}
	
	/**
	 * wait for dialogs to be created before interacting with them, but if they don't appear, then carry on.
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	
	public void writeConditionalCreateDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCreateTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_DIALOG_TO_OPEN_CONDITIONAL);
		String description = getDescription(tokens);
		String fullDescription = "create dialog " + description;
		waitForDialogCreateTemplate = waitForDialogCreateTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCreateTemplate));
	}
	
	/**
	 * write out the click command:
	 * click:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "click on " + description;
		
		// if the activity was switched, or a diaog was just dismissed, wait for the view before clicking on it
		if (mLastEventWasWaitForActivity || mLastEventWasWaitForDialog) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
			mLastEventWasWaitForDialog = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickInViewTemplate =  writeViewIDCommand(Constants.Templates.CLICK_IN_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String clickInClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String clickInInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_VIEW_INTERNAL_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInInternalClassIndexTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	/**
	 * write out the click_workarond command:
	 * Unfortunately, when we click in a dialog, the android call to get the position on the screen
	 * is sometimes off, so we work around it using performClick() rather than sendClickToScreen()
	 * see https://code.google.com/p/robotium/issues/detail?id=431
	 * click_workaround:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	
	public void writeClickWorkaround(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "click workaround on " + description;
		// if the activity was switched, or a diaog was just dismissed, wait for the view before clicking on it
		if (mLastEventWasWaitForActivity || mLastEventWasWaitForDialog) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
			mLastEventWasWaitForDialog = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickInViewTemplate =  writeViewIDCommand(Constants.Templates.CLICK_WORKAROUND_IN_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String clickInClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_WORKAROUND_IN_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String clickInInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_WORKAROUND_IN_VIEW_INTERNAL_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInInternalClassIndexTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the waitForText command:
	 * after_set_text:53749054,"text",1,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "wait for text " + description;
		String text = tokens.get(2);
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String waitForTextTemplate =  writeViewIDCommand(Constants.Templates.WAIT_FOR_TEXT_ID, ref, fullDescription);
			waitForTextTemplate = waitForTextTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, waitForTextTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String waitClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_TEXT_CLASS_INDEX, ref, fullDescription);
			waitClassIndexTemplate = waitClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, waitClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String waitInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
			waitInternalClassIndexTemplate = waitInternalClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, waitInternalClassIndexTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	/**
	 * write out the get_focus command:
	 * get_focus:60065592,internal_class_index,android.widget.EditText,1,0,0
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGetFocus(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "get focus " + description;
		String text = tokens.get(2);
		String insertionStartIndex = tokens.get(tokens.size() - 2);
		String insertionEndIndex = tokens.get(tokens.size() - 1);
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String requestFocusTemplate =  writeViewIDCommand(Constants.Templates.REQUEST_FOCUS_ID, ref, fullDescription);
			requestFocusTemplate = requestFocusTemplate.replace(Constants.VariableNames.INSERTION_START, insertionStartIndex);
			requestFocusTemplate = requestFocusTemplate.replace(Constants.VariableNames.INSERTION_END, insertionEndIndex);
			lines.add(new LineAndTokens(tokens, requestFocusTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String requestFocusClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.REQUEST_FOCUS_CLASS_INDEX, ref, fullDescription);
			requestFocusClassIndexTemplate = requestFocusClassIndexTemplate.replace(Constants.VariableNames.INSERTION_START, insertionStartIndex);
			requestFocusClassIndexTemplate = requestFocusClassIndexTemplate.replace(Constants.VariableNames.INSERTION_END, insertionEndIndex);
			lines.add(new LineAndTokens(tokens, requestFocusClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String requestFocusInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.REQUEST_FOCUS_INTERNAL_CLASS_INDEX, ref, fullDescription);
			requestFocusInternalClassIndexTemplate = requestFocusInternalClassIndexTemplate.replace(Constants.VariableNames.INSERTION_START, insertionStartIndex);
			requestFocusInternalClassIndexTemplate = requestFocusInternalClassIndexTemplate.replace(Constants.VariableNames.INSERTION_END, insertionEndIndex);
			lines.add(new LineAndTokens(tokens, requestFocusInternalClassIndexTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	
	/**
	 * write out the dismiss_autocomplete_dropdown
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissAutoCompleteDropdown(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "dismiss autocomplete dropdown on " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID)  {
			String dismissDropdownIDTemplate =  writeViewIDCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownIDTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String dismissDropdownClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownClassIndexTemplate));			
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String dismissDropdownInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownInternalClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindow(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindowBackKey(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW_BACK_KEY);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.ACTIVITY_VARIABLE_INDEX, Integer.toString(mActivityVariableIndex++));
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	
	/**
	 * rotation:81589683,90,com.example.android.apis.ApiDemos,com.example.android.apis.ApiDemos@4120f1b0
	 * @param tokens parsed from a line in events.tt
	 * @param lines lines output list of java instructions
	 * @throws IOException if the template file can't be read.
	 * @throws EmitterException
	 */
	public void writeRotation(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String rotationTemplate = FileUtility.readTemplate(Constants.Templates.ROTATE);
		int rotation = 0;
		try {
			rotation = Integer.parseInt(tokens.get(2));
		} catch (NumberFormatException nfex) {
			throw new EmitterException("Rotation value " + tokens.get(2) + " failed to parse");
		}
		
		// TODO: add to constants
		String orientationConstant = "ActivityInfo.SCREEN_ORIENTATION_PORTRAIT";
		if (rotation == 0) {
			orientationConstant = "ActivityInfo.SCREEN_ORIENTATION_PORTRAIT";
		} else if (rotation == 90) {
			orientationConstant = "ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE";
		} else if (rotation == 180) {
			orientationConstant = "ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT";
		} else if (rotation == 270) {
			orientationConstant = "ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE";
		} else {
			throw new EmitterException("Rotation value " + rotation + " is not one of 0,90,180,270");
		}
		String fullDescription = "rotate the screen " + rotation + " degrees";
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.ORIENTATION, orientationConstant);
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, rotationTemplate));
	}
	
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeShowIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		if (tokens.size() > 3) {
			ReferenceParser ref = new ReferenceParser(tokens, 2);
			String description = getDescription(tokens);
			String fullDescription = "show IME for " + description;
			if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
				String showImeViewTemplate = writeViewIDCommand(Constants.Templates.SHOW_IME_ID, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, showImeViewTemplate));
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
				String showImeViewTemplate = writeViewClassIndexCommand(Constants.Templates.SHOW_IME_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, showImeViewTemplate));			
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
				String showImeViewTemplate = writeViewInternalClassIndexCommand(Constants.Templates.SHOW_IME_INTERNAL_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, showImeViewTemplate));			
			} else {
				throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
			}
		} else {
			String showImeTemplate = FileUtility.readTemplate(Constants.Templates.SHOW_IME);
			lines.add(new LineAndTokens(tokens, showImeTemplate));			
		}
	}
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeHideIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		if (tokens.size() > 3) {
			ReferenceParser ref = new ReferenceParser(tokens, 2);
			String description = getDescription(tokens);
			String fullDescription = "hide IME for " + description;
			if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
				String hideImeViewTemplate = writeViewIDCommand(Constants.Templates.HIDE_IME_ID, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, hideImeViewTemplate));
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
				String hideImeClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.HIDE_IME_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, hideImeClassIndexTemplate));			
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
				String hideImeInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.HIDE_IME_INTERNAL_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, hideImeInternalClassIndexTemplate));							
			}
		} else {
			String hideImeTemplate = FileUtility.readTemplate(Constants.Templates.SHOW_IME);
			lines.add(new LineAndTokens(tokens, hideImeTemplate));			
		}
	}
	
	/**
	 * write out the scroll command for robotium.  This is different because we're not parsing a line, but
	 * rather the last scroll in a continuous list of scroll events.
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeScroll(ReferenceParser scrollListRef, int scrollFirstVisibleItem, List<String> tokens, List<LineAndTokens> outputLines) throws IOException {
		String scrollListTemplate = FileUtility.readTemplate(Constants.Templates.SCROLL_LIST);
		String description = getDescription(tokens);
		String fullDescription = "scroll down " + description;
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(scrollListRef.getShownIndex()));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.REAL_INDEX, Integer.toString(scrollListRef.getRealIndex()));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(scrollFirstVisibleItem));
		mViewVariableIndex++;
		outputLines.add(new LineAndTokens(tokens, scrollListTemplate));
	}
	
	/**
	 * index:  start, count, after
	 * before_text_key: This method is called to notify you that, within s, the count characters beginning at start have just replaced old text that had length before. 
	 * after_text_key: This method is called to notify you that, within s, the count characters beginning at start are about to be replaced by new text with length after
	 * before_text_key:53749054,"t",1,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,t
	 * after_text_key:53749094,"th",1,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,th
	 * before_text_key:53750798,"th",0,2,8,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,th
	 * after_text_key:53750835,"Thailand",0,2,8,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,Thailand
	 * In the specific 0,2,8 case, the entire text string is being changed.  It could be a past call, it could be from an autocomplete dropdown, we don't know.
	 * we have to update the insertion point
	 * modifies mCurrentText
	 * @param textInsertionPoint: point where the text is being inserted
	 * 
	 * @return true if the text was committed (i.e. the "write" was written) 
	 */
	protected static int numberActualCharsAdded(StringBuffer currentText) {
		int charCount = 0;
		int ich = 0;
		while (ich < currentText.length()) {
			if (ich < currentText.length() - 1) {
				if (currentText.charAt(ich) == '\\') {
					if (currentText.charAt(ich + 1) == 'b') {
						charCount--;
					} else {
						charCount++;
					}
					ich++;
				} else {
					charCount++;
				}	
			} else {
				charCount++;
			}	
			ich++;
		}
		return charCount;
	}
	
	public boolean addChangeToCurrentText(List<String> 				afterTextTokens, 
										  List<LineAndTokens> 		lines) throws IOException, EmitterException {
		int newInsertionPoint = Integer.parseInt(afterTextTokens.get(3));
		int replaceCount = Integer.parseInt(afterTextTokens.get(4));
		int newCharacterCount = Integer.parseInt(afterTextTokens.get(5));
		boolean fCursorChanged = false;

		// take the escaped characters from the token (such as newline), and turn them back into their literal characters, so the
		// indexing is done correctly
		String unescapedString = StringUtils.unescapeString(StringUtils.stripQuotes(afterTextTokens.get(2)), '\\');
		
		// if the new characterCount > 0, then insertion, otherwise deleting characters.
		if (newCharacterCount > 0) {
			
			// just append the characters to the current string to enter if the insertion point hasn't changed.
			String unescapedNewChars = unescapedString.substring(newInsertionPoint, newInsertionPoint + newCharacterCount);
			String insertChars = StringUtils.escapeString(unescapedNewChars, "\t\n", '\\');
			if (mCurrentText.length() == 0) {
				mStartInsertionPoint = newInsertionPoint;
			} else if (newInsertionPoint != mStartInsertionPoint + numberActualCharsAdded(mCurrentText)) {
				// somehow, the insertion point was reset, and we should output the text, then reset the current text to what was just entered.  
				// Since this is usually kicked off by some kind of system event, I'm not sure this case will happen
				writeEnterTextByKey(afterTextTokens, lines, mStartInsertionPoint, mCurrentText.toString());				
				fCursorChanged = true;
				mStartInsertionPoint = newInsertionPoint;
				mCurrentText = new StringBuffer();
			}
			mCurrentText.append(insertChars);
		} else {
			// insert backspaces in the current text if the insertion point moved backward by the correct amount
			// set text resets insertion point in autocomplete case.
			if (mCurrentText.length() == 0) {
				mStartInsertionPoint = newInsertionPoint + replaceCount;
			} else if (newInsertionPoint + replaceCount != mStartInsertionPoint + numberActualCharsAdded(mCurrentText)) {
				writeEnterTextByKey(afterTextTokens, lines, mStartInsertionPoint, mCurrentText.toString());
				fCursorChanged = true;
				mStartInsertionPoint = newInsertionPoint + replaceCount;
				mCurrentText = new StringBuffer();
			}
			for (int iDel = 0; iDel < replaceCount; iDel++) {
				mCurrentText.append("\\b");
			}
		}
		return fCursorChanged;
	}
	
	/**
	 * same as writeEnterText, except calls the key-by-key robotiumUtils function, with an insert index
	 * after_text_key:6702330,this,3,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * after_text_key:time,text,startposition,beforechars,countchars,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @param insertIndex insertion index
	 * @param text text to enter
	 * @throws IOException if the template file can't be read
	 */
	public void writeEnterTextByKey(List<String> tokens, List<LineAndTokens> lines, int insertIndex, String text) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "enter text in " + description;
		/* why is this commented out?  Is this written by the caller? Verify and remove if so.
		if (sLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			sLastEventWasWaitForActivity = false;
		} 
		*/
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.EDIT_TEXT_KEY_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.INSERT, Integer.toString(insertIndex));
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.EDIT_TEXT_KEY_INTERNAL_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.INSERT, Integer.toString(insertIndex));
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			String enterTextIDTemplate = writeViewIDCommand(Constants.Templates.EDIT_TEXT_KEY_ID, ref, fullDescription);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.TEXT, text);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.INSERT, Integer.toString(insertIndex));
			lines.add(new LineAndTokens(tokens, enterTextIDTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write an enterText command from the data from the text watcher
	 * after_text:6702330,this,3,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * after_text:time,text,startposition,beforechars,countchars,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeEnterText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String text =  StringUtils.stripQuotes(tokens.get(2));
		writeEnterText(tokens, lines, text);
	} 
	/**
	 * same, except that the text is passed explicitly
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	
	public void writeEnterText(List<String> tokens, List<LineAndTokens> lines, String text) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "enter text in " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.EDIT_TEXT_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.EDIT_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			String enterTextIDTemplate = writeViewIDCommand(Constants.Templates.EDIT_TEXT_ID, ref, fullDescription);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextIDTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	public void copyText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "copy text " + description;
		String copyTextVar = tokens.get(2);
		String copyTextTemplate = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			copyTextTemplate = writeViewClassIndexCommand(Constants.Templates.COPY_TEXT_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			copyTextTemplate = writeViewInternalClassIndexCommand(Constants.Templates.COPY_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			copyTextTemplate = writeViewIDCommand(Constants.Templates.COPY_TEXT_ID, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		copyTextTemplate = copyTextTemplate.replace(Constants.VariableNames.VARIABLE_NAME, copyTextVar);
		copyTextTemplate = copyTextTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, copyTextTemplate));
	}
	
	public void pasteText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "copy text " + description;
		String copyTextVar = tokens.get(2);
		String copyTextTemplate = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			copyTextTemplate = writeViewClassIndexCommand(Constants.Templates.PASTE_TEXT_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			copyTextTemplate = writeViewInternalClassIndexCommand(Constants.Templates.PASTE_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			copyTextTemplate = writeViewIDCommand(Constants.Templates.PASTE_TEXT_ID, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		copyTextTemplate = copyTextTemplate.replace(Constants.VariableNames.VARIABLE_NAME, copyTextVar);
		copyTextTemplate = copyTextTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, copyTextTemplate));
	}
	
	/**
	 * wait for a list element, where the list is referenced by class and index.
	 * @param tokens
	 * @param itemIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeWaitForListClassIndex(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_LIST_CLASS_INDEX, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	/**
	 * wait for a list element, where the list is referenced by class and index.
	 * @param tokens
	 * @param itemIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeWaitForListInternalClassIndex(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_LIST_INTERNAL_CLASS_INDEX, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	
	/**
	 * List items need a wait for the selected item, not just the list.
	 * @param tokens tokens from the select item call
	 * @param itemIndex index of selected item
	 * @param lines output lines.
	 * @throws IOException
	 */
	public void writeWaitForListIdItem(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_LIST_ID_ITEM, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	
	/**
	 * write the item click event for a list item
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		String itemClickTemplate = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			itemClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			itemClickTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, itemClickTemplate));
	}
	/**
	 * write the item click event for a list item
	 * item_click_by_text:195768219, "this is the item text",class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	
	public void writeItemClickByText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String itemText = StringUtils.unescapeString(StringUtils.stripQuotes(tokens.get(2)), '\\');
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST_BY_TEXT, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_TEXT, itemText);
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String itemClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST_BY_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_TEXT, itemText);
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM_ID_BY_TEXT, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_TEXT, itemText);
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	/**
	 * write the item click event for a menu popup list item
	 * same as item_click event, but we want to differentiate.
	 * menu_item_click:153346865,2,class_index,android.widget.ListPopupWindow$DropDownListView,0,Edit
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writePopupMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String itemClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST_INTERNAL_CLASS_INDEX, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}

	/**
	 * write the item selected event for a spinner
	 * spinner_item_selected:91440728,4,class_index,android.widget.Spinner,0,0,Jupiter
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeSpinnerItemSelected(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2));
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "select item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		
		// TODO: we need to expand RobotiumUtils to select a spinner item based on the spinner ID and internal class index
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			int classIndex = ref.getShownIndex();
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.SELECT_SPINNER_ITEM, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.SPINNER_INDEX, Integer.toString(classIndex));
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		mViewVariableIndex++;	
	}
	
	/**
	 * child_click:105261255,0,0,0,class_index,android.widget.ExpandableListView,0,Arnold
	 */
	public void writeChildClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int groupPosition = Integer.parseInt(tokens.get(2)) + 1;
		int childPosition = Integer.parseInt(tokens.get(3)) + 1;
		int flatListIndex = Integer.parseInt(tokens.get(4)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 5);
		String description = getDescription(tokens);
		String fullDescription = "child click item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		String childClickTemplate = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			childClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			childClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			childClickTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		childClickTemplate = childClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(flatListIndex));
		lines.add(new LineAndTokens(tokens, childClickTemplate));
		mViewVariableIndex++;			
	}
	
	/**
	 * group_click:105266794,1,0, class_index,android.widget.ExpandableListView,0,Dog Names
	 */
	public void writeGroupClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		int flatListIndex = Integer.parseInt(tokens.get(3)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 4);
		String description = getDescription(tokens);
		String fullDescription = "group click item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		String groupClickTemplate = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			groupClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			groupClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			groupClickTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		groupClickTemplate = groupClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(flatListIndex));
		lines.add(new LineAndTokens(tokens, groupClickTemplate));
		mViewVariableIndex++;			
		
	}

	
	/**
	 * write the header on the first activity
	 * TODO: consolidate code defintions between interstitial activity and dialog handlers
	 * @param testPackage com.package.name for the test application
	 * @param testClassName classNameTest<index>
	 * @param className name of the test application
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeHeader(String 					classPath, 
						    String 					testPackage, 
						    String 					testClassName,  
						    String 					className, 
						    BufferedWriter 			bw) throws IOException {
		String header = FileUtility.readTemplate(Constants.Templates.HEADER);
		header = header.replace(Constants.VariableNames.TESTPACKAGE, testPackage);
		header = header.replace(Constants.VariableNames.CLASSPATH, classPath);
		header = header.replace(Constants.VariableNames.CLASSNAME, className);
		header = header.replace(Constants.VariableNames.TESTCLASSNAME, testClassName);
		bw.write(header);
	}

	/**
	 * write the trailer on completion.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write the trailer on completion (split function.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeClassTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.CLASS_TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write a list of lines to a file
	 * @param bw BufferedWriter
	 * @param lines list of lines
	 * @throws IOException
	 */
	public void writeLines(BufferedWriter bw, List<LineAndTokens> lines) throws IOException {
		for (LineAndTokens line : lines) {
			bw.write(line.mOutputLine);
		}
	}
	/**
	 * utility function to write out commands which are based on the view ID for the view reference
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	public String writeViewIDCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.ID, ref.getID());
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		return template;
	}
	/**
	 * same as writeViewIDCommand, except for views referenced by a class and index.
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	
	public String writeViewClassIndexCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		template = template.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(ref.getShownIndex()));
		template = template.replace(Constants.VariableNames.REAL_INDEX, Integer.toString(ref.getRealIndex()));
		return template;
	}
	
	public String writeViewInternalClassIndexCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		template = template.replace(Constants.VariableNames.INTERNAL_CLASS, ref.getInternalClassName());
		template = template.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(ref.getShownIndex()));
		template = template.replace(Constants.VariableNames.REAL_INDEX, Integer.toString(ref.getRealIndex()));
		return template;
	}
	
	/**
	 * on_page_finshed:56051503,id,com.example.android.apis.R$id.wv10,android.webkit.WebView,WebView,url
	 */
	public void waitForPageToLoad(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String template = "";
		String url = tokens.get(6);
		String fullDescription = "wait for URL " + url;
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			template = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			template = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			template = writeViewIDCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_ID, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		template = template.replace(Constants.VariableNames.URL, url);
		lines.add(new LineAndTokens(tokens, template));
	}
	
	/**
	 * touch_down:20903880,720,176,139.80583,102.80562,id,0x7f0900a2,android.widget.Gallery,Gallery
	 * @param tokens
	 * @param motionEvents
	 */
	public int writeMotionEvents(List<List<String>>		tokenLines,
								  int					currentReadIndex,
								  String 				testClassName, 
								  List<MotionEventList> motionEvents, 
								  List<LineAndTokens>   lines) throws IOException, EmitterException {
		List<String> tokens = tokenLines.get(currentReadIndex);
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			mLastEventWasWaitForActivity = false;
		} 
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String uniqueName = (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) ? ref.getID() : (ref.getClassName() + ref.getShownIndex());
		String name = uniqueName + "_MotionEvents" + Integer.toString(mMotionEventVariableIndex);
		MotionEventList motionEventList = new MotionEventList(name, tokens, tokenLines, currentReadIndex);
		motionEvents.add(motionEventList);
		ReferenceParser refEvents = motionEventList.getRef();
		String fullDescription = "play back motion events";
		String template = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			template = writeViewIDCommand(Constants.Templates.PLAYBACK_MOTION_EVENTS, refEvents, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			template = writeViewClassIndexCommand(Constants.Templates.PLAYBACK_MOTION_EVENTS_CLASS_INDEX, refEvents, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			template = writeViewInternalClassIndexCommand(Constants.Templates.PLAYBACK_MOTION_EVENTS_INTERNAL_CLASS_INDEX, refEvents, fullDescription);
		}
		template = template.replace(Constants.VariableNames.MOTION_EVENT_VARIABLE_INDEX, Integer.toString(mMotionEventVariableIndex));
		template = template.replace(Constants.VariableNames.UNIQUE_NAME, uniqueName);
		lines.add(new LineAndTokens(tokens, template));
		mMotionEventVariableIndex++;
		return motionEventList.getLastReadIndex();
	}
	
	/**
	 *  check to see if two token lists match.  Of course, don't check the timestamp.
	 * @return true if they match, false otherwise, foo.
	 */
	public boolean matchTokens(List<String> a, List<String> b) {
		if (a.size() != b.size()) {
			return false;			
		} else {
			for (int i = 0; i < a.size(); i++) {
				if (i != 1) {
					if (!a.get(i).equals(b.get(i))) {
						return false;
					}
				}	
			}
			return true;
		}
	}
	
	/**
	 * read the target package in advance, because that gives us the name of the application that we're testing
	 * and we can get the directory of the test app that we're generating to read the handlers from so we can
	 * insert them in the output code.
	 * NOTE: if this would set the target package member variable, it would make scanTargetPackage obsolete
	 * @param eventsFileName
	 * @return
	 * @throws IOException
	 */
	public String readApplicationPackage(String eventsFileName) throws IOException {
		BufferedReader br = new BufferedReader(new FileReader(eventsFileName));
		String line = br.readLine();
		String targetPackage = null;
		while (line != null) {
			SuperTokenizer st = new SuperTokenizer(line, "\"", ":,", '\\');
			List<String> tokens = st.toList();
			String action = tokens.get(1);
			if (Constants.ActivityEvent.PACKAGE.equals(action)) {
				targetPackage = tokens.get(3);
				break;
			}
			line = br.readLine();
		}
		br.close();
		return targetPackage;
	}
	
	// find the matching code definition to this list of tokens.
	public CodeDefinition findConditionalCode(List<String> 									 tokens, 
											  Hashtable<CodeDefinition, List<LineAndTokens>> outputCode) {
		for (Entry<CodeDefinition, List<LineAndTokens>>  entry : outputCode.entrySet()) {
			CodeDefinition codeDef = entry.getKey();
			if (codeDef.getPrecedingTokens() != null) {
				if (matchTokens(codeDef.getPrecedingTokens(), tokens)) {
					return codeDef;
				}
			}
		}
		return null;
	}
		
	/**
	 * after an activity has been marked as interstitial, and we've hit the matching tokens, we need to scan
	 * to the next activity_transition event, with a matching activity name, then one with a different activity name
	 * @param tokenLines
	 * @param tokenScanner
	 * @param codeDef
	 * @param currentIndex
	 * @return
	 */
	public int findClosingActivity(List<List<String>> 	tokenLines,
								   TokenScanner			tokenScanner,
								   CodeDefinition		codeDef,
								   int					currentIndex) {
		Predicate activityTransitionPredicate =  tokenScanner.new ActivityTransitionPredicate();
		int activityTransitionIndex = TokenScanner.scanForward(tokenLines, currentIndex, activityTransitionPredicate);
		List<String> activityTransitionTokens = tokenLines.get(activityTransitionIndex);
		String activityName = activityTransitionTokens.get(2);
		
		// positive case: the interstitial activity was fired.  We search for the next activity transition and skip it
		// because the interstitial handler waits for the activity transition.  NOTE: The outer loop skips it for us
		if (activityName.equals(codeDef.getActivityName())) {
			int nextActivityTransitionIndex = TokenScanner.scanForward(tokenLines, activityTransitionIndex + 1, activityTransitionPredicate);
			if (nextActivityTransitionIndex == -1) {
				return tokenLines.size() - 1;
			} else {
				return nextActivityTransitionIndex + 1;
			}
		} else {
			// negative case.  The interstitial activity was not fired, so we just write the condition and keep going
			return currentIndex; 
		}
	}
	
	/**
	 * aftr a dialog has been marked as interstitial, and we've hit the matching tokens, we scan for the next 
	 * create_dialog event, then we scan to the next activity close.  If there's a system event or a user event
	 * before then, then the dialog didn't fire, so we just insert the dialog code
	 * @param tokenLines
	 * @param tokenScanner
	 * @param codeDef
	 * @param currentIndex
	 * @return
	 */
	public int findDialogClose(List<List<String>> 	tokenLines,
							   TokenScanner			tokenScanner,
							   CodeDefinition		codeDef,
							   int					currentIndex) {
		Predicate dialogOpenPredicate = tokenScanner.new EventListPredicate(Constants.SystemEvent.CREATE_DIALOG.mEventName);
		
		// see if there is a dialog open event before the next user or activity transition event.
		// TODO: we will write the dialog description for an interstitial dialog
		int dialogOpenIndex = TokenScanner.scanForward(tokenLines, currentIndex, dialogOpenPredicate);
		Predicate nextEventPredicate = tokenScanner.new OrPredicate(tokenScanner.new ActivityTransitionPredicate(),
														  		    tokenScanner.new UserEventPredicate());
		int nextEventIndex = TokenScanner.scanForward(tokenLines, currentIndex, nextEventPredicate);
		if (nextEventIndex > dialogOpenIndex) {
												
			Predicate dialogClosePredicate = tokenScanner.new OrPredicate(tokenScanner.new DialogClosePredicate(),
																	      tokenScanner.new ActivityTransitionPredicate());
			int dialogCloseIndex = TokenScanner.scanForward(tokenLines, dialogOpenIndex + 1, dialogClosePredicate);
			return dialogCloseIndex;
		} else {
			return currentIndex;
		}
	}

}
