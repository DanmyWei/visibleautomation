package com.androidApp.emitter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

import com.androidApp.emitter.IEmitCode.LineAndTokens;
import com.androidApp.parser.ProjectPropertiesScan;
import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * @author Matthew
 * Copyright (c) 2013 Visible Automation LLC.  All Rights Reserved.
 * TODO: All Events MUST respect mLastEventWasWaitForActivity, not just click
 * TODO: add mLastEventWasCreateDialog for the same thing
 */
public class EmitRobotiumCodeSource implements IEmitCode {
	protected int 			mViewVariableIndex = 0;					// incremented for unique view variable names
	protected int 			mActivityVariableIndex = 0;				// incremented for unique activity variable names
	protected int 			mMotionEventVariableIndex = 0;			// incremented for unique motion event file names
	protected String 		mTargetClassPath = null;				// class path of initial activity.	
	protected String 		mTargetPackage = null;					// package name that the recorder pulled from the app
	private boolean 		mLastEventWasWaitForActivity = false;	// want to do a waitForView for next event.
	protected String 		mCurrentActivityName = null;			// current activity name (from activity transition)
	protected String 		mActivityVariable = null;				// variable name for this activity
	protected boolean 		mfActivityMatches = false;				// new activity has same name as current activity
	protected int			mStartInsertionPoint = 0;				// start insertion (for when we insert multichar)
	protected StringBuffer 	mCurrentText = new StringBuffer();		// for tracking text entry
	protected boolean		mfFirstKey = true;						// latch for text entry start
	protected static int	sLineNumber = 0;						// track line # throughout recursions
	
	public EmitRobotiumCodeSource() {
	}	
		
	/**
	 * return the fully qualified class path of the application under test
	 * @return
	 */
	public String getApplicationClassPath() {
		return mTargetClassPath;
	}
	
	/**
	 * return the class name of the application under test
	 * @return
	 */
	public String getApplicationClassName() {
		if (mTargetClassPath != null) {
			return StringUtils.getNameFromClassPath(mTargetClassPath);
		} else {
			return null;
		}
	}
	
	/**
	 * return the package name of the application under test.
	 * @return
	 */
	public String getApplicationPackage() {
		return mTargetPackage;
	}
	
	/**
	 * take the events file name (which may be the reserved word "device", and emit the test code into
	 * an array list of the output code with its associated source tokens
	 * @param emitter the emitter
	 * @param eventsFileName source events file, or device if we pull it from the device.
	 * @return list of test code and source tokens.
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws EmitterException
	 */
	public Hashtable<String, List<LineAndTokens>> generateTestCode(IEmitCode emitter, String eventsFileName, List<MotionEventList> motionEvents) throws FileNotFoundException, IOException, EmitterException {
		Hashtable<String, List<LineAndTokens>> outputCode = new Hashtable<String, List<LineAndTokens>>();
		BufferedReader br = new BufferedReader(new FileReader(eventsFileName));
		List<LineAndTokens> mainLines = emitter.emit(br, outputCode, motionEvents, false);
		outputCode.put(Constants.MAIN, mainLines);
		return outputCode;
	}

	
	/**
	 * actually emit robotium code from a recorded file
	 * TODO: change this so it returns the target class path and class name, not modifying statics
	 * @param br BufferedReader on events.txt file
	 * @param appOutput application output class: lines for main and interstitial activities.
	 * @param lines output lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	@Override
	public List<LineAndTokens> emit(BufferedReader 							br, 
									Hashtable<String, List<LineAndTokens>>	outputCode,
									List<MotionEventList> 					motionEvents,
									boolean									fInterstitialActivity) throws IOException, EmitterException {
		boolean scrollsHaveHappened = false;				// we get a zillion scroll events.  We only care about the last one
		int scrollFirstVisibleItem = 0;						// preserve scroll values so we can apply it on the last scroll.
		int scrollListIndex = 0;							// track the current scroll index to write on the next non-scroll instruction
		List<String> clickSpinnerDialogTokens = null;		// workaround for robotium, which selects spinners, but doesn't just click-dismiss
		String line = br.readLine();	
		int sLineNumber = 0;												// track line number for errors
		List<LineAndTokens> lines = new ArrayList<LineAndTokens>();		// output code for this scope
		do {
			if (line == null) {
				break;
			}
			sLineNumber++;
			try {
				String nextLine = br.readLine();
				// syntax is event:time,arguments,separated,by,commas
				SuperTokenizer st = new SuperTokenizer(line, "\"", ":,", '\\');
				List<String> tokens = st.toList();
				
				// we peek at the next line to see if it's an activity_forward or an activity back, and save the activity name so it can be 
				// waited for.
				List<String> nextTokens = null;
				if (nextLine != null) {
					SuperTokenizer stNext = new SuperTokenizer(nextLine, "\"", ":,", '\\');
					nextTokens = stNext.toList();
					checkActivityTransition(tokens, nextTokens, lines);
				}
				String action = tokens.get(0);
				
				// when the recorder scrolls, it writes out a scroll message for each move, but
				// we just want robotium to issue a single scroll command, so once we read a scroll
				// command, we wait until a scroll happens on another listview, or a different event
				// has occurred, and we scroll to the last list item that was recorded.
				if (scrollsHaveHappened) {
					if (!Constants.UserEvent.SCROLL.equals(action)) {
						writeScroll(scrollListIndex, scrollFirstVisibleItem, tokens, lines);
						scrollsHaveHappened = false;
					} else {
						// scroll:195758909,0,11,11,class_index,android.widget.ListView,1
						// command:time,firstVisible,visibleItemCount,totalItemCount,[view reference]
						int scrollListIndexTest = Integer.parseInt(tokens.get(7));
						if (scrollListIndexTest != scrollListIndex) {
							writeScroll(scrollListIndex, scrollFirstVisibleItem, tokens, lines);
							scrollsHaveHappened = false;
						}
					}
				}				
				
				// then everything else is switched on the event name.
				if (Constants.ActivityEvent.PACKAGE.equals(action)) {
					mTargetPackage = tokens.get(2);
				} else if (Constants.ActivityEvent.INTERSTITIAL_ACTIVITY.equals(action)) {
					String newActivityName = tokens.get(2);
					List<LineAndTokens> activityLines = emit(br, outputCode, motionEvents, true);
					outputCode.put(newActivityName, activityLines);
				} else if (Constants.ActivityEvent.ACTIVITY_FORWARD.equals(action)) {
					// if we're in an interstitial, that means that it's time to go.
					if (fInterstitialActivity) {
						return lines;
					}
					if (mTargetClassPath == null) {
						mTargetClassPath = tokens.get(2);
					}
					mLastEventWasWaitForActivity = true;
					if (mfActivityMatches) {
						writeWaitForMatchingActivity(mActivityVariable, tokens, lines);
					} else {
						writeWaitForActivity(tokens, lines);
					}
				} else if (Constants.ActivityEvent.ACTIVITY_BACK.equals(action) || Constants.UserEvent.ACTIVITY_BACK_KEY.equals(action)) {
					// the handler is responsible for managing the activity transtion, but we do need to record the 
					// fact that the user used the back key to get out if he
					if (fInterstitialActivity) {
						if (Constants.UserEvent.ACTIVITY_BACK_KEY.equals(action)) {
							writeGoBack(tokens, lines);
							return lines;
						}
					}
					// I think this is technically incorrect, since the "back" event doesn't always happen from the back key
					// but some other event like a click, and we should use a different template
					if ((tokens.size() > 2) && mfActivityMatches) {
						writeGoBackToMatchingActivity(mActivityVariable, tokens, lines);
					} else {
						writeGoBackAndWaitForActivity(tokens, lines);
					}
					mLastEventWasWaitForActivity = true;
				} else {
					if (Constants.UserEvent.ITEM_CLICK.equals(action)) {
						writeItemClick(tokens, lines);
					} else if (Constants.UserEvent.POPUP_MENU_ITEM_CLICK.equals(action)) {
						writePopupMenuItemClick(tokens, lines);
					} else if (Constants.UserEvent.ITEM_SELECTED.equals(action)) {
						writeItemSelected(tokens, lines);
					} else if (Constants.UserEvent.GROUP_CLICK.equals(action)) {
						writeGroupClick(tokens, lines);
					} else if (Constants.UserEvent.GROUP_CLICK.equals(action)) {
						writeChildClick(tokens, lines);
					} else if (Constants.UserEvent.SCROLL.equals(action)) {
						scrollFirstVisibleItem = Integer.parseInt(tokens.get(2));
						scrollsHaveHappened = true;
						scrollListIndex = Integer.parseInt(tokens.get(7));
					} else if (Constants.UserEvent.CLICK.equals(action)) {
						writeClick(tokens, lines);
					} else if (Constants.SystemEvent.DISMISS_DIALOG.equals(action)) {
						writeDismissDialog(tokens, lines);
					} else if (Constants.UserEvent.CANCEL_DIALOG.equals(action)) {
						writeCancelDialog(tokens, lines);
					} else if (Constants.SystemEvent.CREATE_DIALOG.equals(action)) {
						writeCreateDialog(tokens, lines);
					} else if (Constants.SystemEvent.SHOW_IME.equals(action)) {
						writeShowIME(tokens, lines);
					} else if (Constants.SystemEvent.HIDE_IME.equals(action) ||
							   Constants.UserEvent.HIDE_IME_BACK_KEY.equals(action)) {
						writeHideIME(tokens, lines);
					} else if (Constants.UserEvent.BEFORE_TEXT.equals(action) || 
							   Constants.UserEvent.BEFORE_TEXT_KEY.equals(action)) {
						if (mCurrentText.length() == 0) {
							mStartInsertionPoint = Integer.parseInt(tokens.get(3));
						}
					} else if (Constants.UserEvent.AFTER_TEXT_KEY.equals(action)) {
						if (!addChangeToCurrentText(tokens, lines)) {			
							String nextAction = nextTokens.get(0);
							// if the next event isn't a before_text_key event, and it's some kind of other user event,
							// then spit out the text.  We don't spit in all cases, because a system event (like an
							// autocorrect dropdown appearing/disappearing might happen, and it doesn't affect text entry)
							if (!Constants.UserEvent.BEFORE_TEXT_KEY.equals(nextAction) && (mCurrentText.length() > 0)) {
								writeEnterTextByKey(tokens, lines, mStartInsertionPoint, mCurrentText.toString());
								mCurrentText = new StringBuffer();
							}
						}
					} else if (Constants.UserEvent.AFTER_TEXT.equals(action)) {
						// if the next event isn't "before_text", then spit out the text in a solo.enterText() call
						String nextAction = nextTokens.get(0);
						if (!Constants.UserEvent.BEFORE_TEXT.equals(nextAction)) {
							writeEnterText(tokens, lines);
						}	
					} else if (Constants.SystemEvent.AFTER_SET_TEXT.equals(action)) {
						writeWaitForText(tokens, lines);
					} else if (Constants.SystemEvent.DISMISS_AUTOCOMPLETE_DROPDOWN.equals(action)) {
						writeDismissAutoCompleteDropdown(tokens, lines);
					} else if (Constants.UserEvent.DISMISS_POPUP_WINDOW_BACK_KEY.equals(action)) {
						writeDismissPopupWindowBackKey(tokens, lines);
					} else if (Constants.SystemEvent.CREATE_SPINNER_POPUP_DIALOG.equals(action)) {
						clickSpinnerDialogTokens = tokens;
					} else if (Constants.UserEvent.DISMISS_SPINNER_DIALOG_BACK_KEY.equals(action)) {
						writeClick(clickSpinnerDialogTokens, lines);
						writeGoBack(tokens, lines);
						writeDismissDialog(tokens,lines);
					} else if (Constants.UserEvent.DISMISS_SPINNER_POPUP_BACK_KEY.equals(action)) {
						writeClick(tokens, lines);
						writeDismissPopupWindowBackKey(tokens, lines);
					} else if (Constants.SystemEvent.ROTATION.equals(action)) {
						writeRotation(tokens, lines);
					} else if (Constants.UserEvent.MENU_ITEM_CLICK.equals(action)) {
						writeMenuItemClick(tokens, lines);
					} else if (Constants.SystemEvent.EXCEPTION.equals(action)) {
						writeException(tokens, lines);
					} else if (Constants.UserEvent.SELECT_ACTIONBAR_TAB.equals(action)) {
						selectActionBarTab(tokens, lines);
					} else if (Constants.UserEvent.SELECT_TAB.equals(action)) {
						selectTab(tokens, lines);
					} else if (Constants.SystemEvent.ON_PAGE_FINISHED.equals(action)) {
						// TODO: TEMPORARY for DEMO
						// waitForPageToLoad(tokens, lines);
					} else if (Constants.UserEvent.TOUCH_DOWN.equals(action) || Constants.UserEvent.TOUCH_MOVE.equals(action)) {
						// we have to listen for the first "touch move", not just touch down, because scroll containers
						// don't actually fire the TouchEvent listener for TOUCH_DOWN because it dispatches the event
						// to a child object, and does not call View.dispatchTouchEvent() for the scrolling view.
						// there may be a way around this
						writeMotionEvents(tokens, nextLine, getApplicationClassName(), br, motionEvents, lines);
						// read the line after touch_up
						nextLine = br.readLine();
					}
				}
				line = nextLine;
			} catch (Exception ex) {
				System.err.println("error parsing line " + sLineNumber);
				System.err.println("line = " + line);
				ex.printStackTrace();
				System.exit(-1);
			}
		} while (true);
		return lines;
	}
	
	/**
	 * for an activity forward or activity back
	 * member variables: set mCurrentActivityName if the event was activity_forward
	 * mfActivityMatches: there was an activity transition, and the activity transitioned to has the same name
	 * mActivityVariable: variable name assigned to the activity transitioned to.
	 * @param tokens tokens for the current line
	 * @param nextTokens tokens for the lookahead next line
	 * @param lines output if we record an activity transition.
	 * @return true if there was an activity transition
	 */
	protected boolean checkActivityTransition(List<String> tokens, List<String> nextTokens, List<LineAndTokens> lines) throws IOException {
		// if it's the first "activity_forward", then it's the class
		if (Constants.ActivityEvent.ACTIVITY_FORWARD.equals(tokens.get(0))) {
			if (mTargetClassPath == null) {
				mTargetClassPath =  tokens.get(2);
				mCurrentActivityName = tokens.get(2);
			}
		}
		if (nextTokens.size() > 2) {
			String nextAction = nextTokens.get(0);
			if (Constants.ActivityEvent.ACTIVITY_FORWARD.equals(nextAction) || 
			    Constants.ActivityEvent.ACTIVITY_BACK.equals(nextAction) || 
			    Constants.UserEvent.ACTIVITY_BACK_KEY.equals(nextAction)) {
				String nextActivityName = nextTokens.get(2);
				mfActivityMatches = nextActivityName.equals(mCurrentActivityName);
				if (mfActivityMatches) {
					mActivityVariable = writeGetCurrentActivity(tokens, lines);
				}
				mCurrentActivityName = nextActivityName;
				return true;
			} 
		}
		return false;
	}

	
	/**
	 * the description is written as the last token
	 * @param lines
	 */
	public String getDescription(List<String> tokens) {
		return tokens.get(tokens.size() - 1);
	}
	
	/**
	 * write the test function header
	 * @param bw output writer
	 * @throws IOException if the function header template can't be read
	 */
	public void writeFunctionHeader(BufferedWriter bw) throws IOException {
		String testFunction = FileUtility.readTemplate(Constants.Templates.TEST_FUNCTION);
		bw.write(testFunction);
	}
	
	/**
	 * write the exception and its description
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeException(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String exceptionTemplate = FileUtility.readTemplate(Constants.Templates.EXCEPTION);
		String description = tokens.get(2);
		exceptionTemplate = exceptionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		lines.add(new LineAndTokens(tokens, exceptionTemplate));				
	}
	
	/**
	 * write the select action bar event select_actionbar_tab:90167820,0,Select tab earth
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void selectActionBarTab(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String selectActionBarTabTemplate = FileUtility.readTemplate(Constants.Templates.SELECT_ACTIONBAR_TAB);
		String tabIndex = tokens.get(2);
		String description = tokens.get(3);
		selectActionBarTabTemplate = selectActionBarTabTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		selectActionBarTabTemplate = selectActionBarTabTemplate.replace(Constants.VariableNames.TAB_INDEX, tabIndex);
		lines.add(new LineAndTokens(tokens, selectActionBarTabTemplate));
	}
	/**
	 * write the select tab event select_tab:88338018,id,0x1020012,android.widget.TabHost,tab3
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void selectTab(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String description = "select tab";
		String selectTabTemplate = "";
		String tabId = tokens.get(5);
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		// NOTE: need to search resource files for the tab id's
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			selectTabTemplate = writeViewIDCommand(Constants.Templates.SELECT_TAB_ID, ref, description);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			selectTabTemplate = writeViewClassIndexCommand(Constants.Templates.SELECT_TAB_CLASS_INDEX, ref, description);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			selectTabTemplate = writeViewInternalClassIndexCommand(Constants.Templates.SELECT_TAB_INTERNAL_CLASS_INDEX, ref, description);
		}
		selectTabTemplate = selectTabTemplate.replace(Constants.VariableNames.TAB_ID, tabId);
		lines.add(new LineAndTokens(tokens, selectTabTemplate));
	}
	
	

	/**
	 * write the invokeMenuActionSync() call
	 * @param tokens
	 * @param startIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String menuItemClickTemplate = FileUtility.readTemplate(Constants.Templates.MENU_ITEM_CLICK);
		String menuItemId = tokens.get(2);
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.MENU_ITEM_ID, menuItemId);
		mViewVariableIndex++;
		lines.add(new LineAndTokens(tokens, menuItemClickTemplate));				
	}

	/**
	 * write the getCurrentActivity() call
	 * @param lines
	 * @throws IOException
	 */
	public String writeGetCurrentActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String getCurrentActivityTemplate = FileUtility.readTemplate(Constants.Templates.GET_CURRENT_ACTIVITY);
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.DESCRIPTION, "get the current activity, since the next one has the same class name");
		lines.add(new LineAndTokens(null, getCurrentActivityTemplate));
		String activityName = Constants.Names.ACTIVITY + Integer.toString(mActivityVariableIndex);
		return activityName;
	}
	
	/**
	 * when we send an event to a view just after we do waitForActivity(), some applications (like ApiDemos) use the same activity
	 * with different contents, so it returns immediately, even though the new screen is up.  If there's just been a waitForActivity(), 
	 * then the next view-based event should do a waitForView(), to make sure that the view's actually been shown.
	 * @param tokens parsed from a line in events.txt
	 * @param startIndex starting index of the view reference
	 * @param lines output list of java instructions
	 * 
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForView(List<String> tokens, int startIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, startIndex);
		String description = getDescription(tokens);
		String fullDescription = "wait for view " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String waitForViewTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String waitForClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForClassIndexTemplate));			
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String waitForInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_VIEW_INTERNAL_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForInternalClassIndexTemplate));			
		}
		mViewVariableIndex++;
	}
	
	
	/**
	 * the application has finished an activity, or set of activities, so we just need to wait for the activity.
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the solo.goBack() call
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBack(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
		lines.add(new LineAndTokens(tokens, goBackTemplate));			
	}
	
	/**
	 * write the solo.goBack() call
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackAndWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		if (tokens.size() > 2) {
			String classPath = tokens.get(2);
			String description = getDescription(tokens);
			String fullDescription = "wait for activity " + description;
			String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK_WAIT_ACTIVITY);
			goBackTemplate = goBackTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
			goBackTemplate = goBackTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
			lines.add(new LineAndTokens(tokens, goBackTemplate));
		} else {
			String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
			lines.add(new LineAndTokens(tokens, goBackTemplate));			
		}
	}

	/**
	 * solo.waitForActivity() when we go forward or back to an activity
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * when we go forward to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeWaitForMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_NEW_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the expression for waitForDialogToClose
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeDismissDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCloseTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_CLOSE_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "dismiss dialog " + description;
		waitForDialogCloseTemplate = waitForDialogCloseTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCloseTemplate));
	}
	/**
	 * write the expression for goBack() for a dialog
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeCancelDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCancelTemplate = FileUtility.readTemplate(Constants.Templates.CANCEL_DIALOG_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "cancel dialog " + description;
		waitForDialogCancelTemplate = waitForDialogCancelTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCancelTemplate));
	}
	
	/**
	 * wait for dialogs to be created before interacting with them
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeCreateDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCreateTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_DIALOG_TO_OPEN);
		String description = getDescription(tokens);
		String fullDescription = "cancel dialog " + description;
		waitForDialogCreateTemplate = waitForDialogCreateTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCreateTemplate));
	}
	
	/**
	 * write out the click command:
	 * click:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "click on " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickInViewTemplate =  writeViewIDCommand(Constants.Templates.CLICK_IN_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String clickInClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String clickInInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_VIEW_INTERNAL_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInInternalClassIndexTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the waitForText command:
	 * after_set_text:53749054,"text",1,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "click on " + description;
		String text = tokens.get(2);
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickInViewTemplate =  writeViewIDCommand(Constants.Templates.WAIT_FOR_TEXT_ID, ref, fullDescription);
			clickInViewTemplate = clickInViewTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, clickInViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String clickInClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_TEXT_CLASS_INDEX, ref, fullDescription);
			clickInClassIndexTemplate = clickInClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, clickInClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String clickInInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
			clickInInternalClassIndexTemplate = clickInInternalClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, clickInInternalClassIndexTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss_autocomplete_dropdown
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissAutoCompleteDropdown(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "dismiss autocomplete dropdown on " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID)  {
			String dismissDropdownIDTemplate =  writeViewIDCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownIDTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String dismissDropdownClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownClassIndexTemplate));			
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String dismissDropdownInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownInternalClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindow(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindowBackKey(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW_BACK_KEY);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.ACTIVITY_VARIABLE_INDEX, Integer.toString(mActivityVariableIndex++));
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	
	/**
	 * rotation:81589683,90,com.example.android.apis.ApiDemos,com.example.android.apis.ApiDemos@4120f1b0
	 * @param tokens parsed from a line in events.tt
	 * @param lines lines output list of java instructions
	 * @throws IOException if the template file can't be read.
	 * @throws EmitterException
	 */
	public void writeRotation(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String rotationTemplate = FileUtility.readTemplate(Constants.Templates.ROTATE);
		int rotation = 0;
		try {
			rotation = Integer.parseInt(tokens.get(2));
		} catch (NumberFormatException nfex) {
			throw new EmitterException("Rotation value " + tokens.get(2) + " failed to parse");
		}
		
		// TODO: add to constants
		String orientationConstant = "Surface.ROTATION_0";
		if (rotation == 0) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 90) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 180) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 270) {
			orientationConstant = "Surface.ROTATION_0";
		} else {
			throw new EmitterException("Rotation value " + rotation + " is not 0,90,180,270");
		}
		String fullDescription = "rotate the screen " + rotation + " degrees";
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.ORIENTATION, orientationConstant);
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, rotationTemplate));
	}
	
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeShowIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		if (tokens.size() > 3) {
			ReferenceParser ref = new ReferenceParser(tokens, 2);
			String description = getDescription(tokens);
			String fullDescription = "show IME for " + description;
			if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
				String showImeViewTemplate = writeViewIDCommand(Constants.Templates.SHOW_IME_ID, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, showImeViewTemplate));
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
				String showImeViewTemplate = writeViewClassIndexCommand(Constants.Templates.SHOW_IME_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, showImeViewTemplate));			
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
				String showImeViewTemplate = writeViewInternalClassIndexCommand(Constants.Templates.SHOW_IME_INTERNAL_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, showImeViewTemplate));			
			} else {
				throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
			}
		} else {
			String showImeTemplate = FileUtility.readTemplate(Constants.Templates.SHOW_IME);
			lines.add(new LineAndTokens(tokens, showImeTemplate));			
		}
	}
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeHideIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		if (tokens.size() > 3) {
			ReferenceParser ref = new ReferenceParser(tokens, 2);
			String description = getDescription(tokens);
			String fullDescription = "hide IME for " + description;
			if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
				String hideImeViewTemplate = writeViewIDCommand(Constants.Templates.HIDE_IME_ID, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, hideImeViewTemplate));
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
				String hideImeClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.HIDE_IME_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, hideImeClassIndexTemplate));			
			} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
				String hideImeInternalClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.HIDE_IME_INTERNAL_CLASS_INDEX, ref, fullDescription);
				lines.add(new LineAndTokens(tokens, hideImeInternalClassIndexTemplate));							
			}
		} else {
			String hideImeTemplate = FileUtility.readTemplate(Constants.Templates.SHOW_IME);
			lines.add(new LineAndTokens(tokens, hideImeTemplate));			
		}
	}
	
	/**
	 * write out the scroll command for robotium.  This is different because we're not parsing a line, but
	 * rather the last scroll in a continuous list of scroll events.
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeScroll(int scrollListIndex, int scrollFirstVisibleItem, List<String> tokens, List<LineAndTokens> outputLines) throws IOException {
		String scrollListTemplate = FileUtility.readTemplate(Constants.Templates.SCROLL_LIST);
		String description = getDescription(tokens);
		String fullDescription = "scroll down " + description;
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(scrollListIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(scrollFirstVisibleItem));
		mViewVariableIndex++;
		outputLines.add(new LineAndTokens(tokens, scrollListTemplate));
	}
	
	/**
	 * index:  start, count, after
	 * before_text_key: This method is called to notify you that, within s, the count characters beginning at start have just replaced old text that had length before. 
	 * after_text_key: This method is called to notify you that, within s, the count characters beginning at start are about to be replaced by new text with length after
	 * before_text_key:53749054,"t",1,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,t
	 * after_text_key:53749094,"th",1,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,th
	 * before_text_key:53750798,"th",0,2,8,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,th
	 * after_text_key:53750835,"Thailand",0,2,8,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView,Thailand
	 * In the specific 0,2,8 case, the entire text string is being changed.  It could be a past call, it could be from an autocomplete dropdown, we don't know.
	 * we have to update the insertion point
	 * modifies mCurrentText
	 * @param textInsertionPoint: point where the text is being inserted
	 * 
	 * @return true if the text was committed (i.e. the "write" was written) 
	 */
	protected static int numberActualCharsAdded(StringBuffer currentText) {
		int charCount = 0;
		int ich = 0;
		while (ich < currentText.length()) {
			if (ich < currentText.length() - 1) {
				if (currentText.charAt(ich) == '\\') {
					if (currentText.charAt(ich + 1) == 'b') {
						charCount--;
					} else {
						charCount++;
					}
					ich++;
				} else {
					charCount++;
				}	
			} else {
				charCount++;
			}	
			ich++;
		}
		return charCount;
	}
	
	public boolean addChangeToCurrentText(List<String> 				afterTextTokens, 
										  List<LineAndTokens> 		lines) throws IOException, EmitterException {
		int newInsertionPoint = Integer.parseInt(afterTextTokens.get(3));
		int replaceCount = Integer.parseInt(afterTextTokens.get(4));
		int newCharacterCount = Integer.parseInt(afterTextTokens.get(5));
		boolean fCursorChanged = false;

		// take the escaped characters from the token (such as newline), and turn them back into their literal characters, so the
		// indexing is done correctly
		String unescapedString = StringUtils.unescapeString(StringUtils.stripQuotes(afterTextTokens.get(2)), '\\');
		
		// if the new characterCount > 0, then insertion, otherwise deleting characters.
		if (newCharacterCount > 0) {
			
			// just append the characters to the current string to enter if the insertion point hasn't changed.
			String unescapedNewChars = unescapedString.substring(newInsertionPoint, newInsertionPoint + newCharacterCount);
			String insertChars = StringUtils.escapeString(unescapedNewChars, "\t\n", '\\');
			if (mCurrentText.length() == 0) {
				mStartInsertionPoint = newInsertionPoint;
			} else if (newInsertionPoint != mStartInsertionPoint + numberActualCharsAdded(mCurrentText)) {
				// somehow, the insertion point was reset, and we should output the text, then reset the current text to what was just entered.  
				// Since this is usually kicked off by some kind of system event, I'm not sure this case will happen
				writeEnterTextByKey(afterTextTokens, lines, mStartInsertionPoint, mCurrentText.toString());				
				fCursorChanged = true;
				mStartInsertionPoint = newInsertionPoint;
				mCurrentText = new StringBuffer();
			}
			mCurrentText.append(insertChars);
		} else {
			// insert backspaces in the current text if the insertion point moved backward by the correct amount
			// set text resets insertion point in autocomplete case.
			if (mCurrentText.length() == 0) {
				mStartInsertionPoint = newInsertionPoint + replaceCount;
			} else if (newInsertionPoint + replaceCount != mStartInsertionPoint + numberActualCharsAdded(mCurrentText)) {
				writeEnterTextByKey(afterTextTokens, lines, mStartInsertionPoint, mCurrentText.toString());
				fCursorChanged = true;
				mStartInsertionPoint = newInsertionPoint + replaceCount;
				mCurrentText = new StringBuffer();
			}
			for (int iDel = 0; iDel < replaceCount; iDel++) {
				mCurrentText.append("\\b");
			}
		}
		return fCursorChanged;
	}
	
	/**
	 * same as writeEnterText, except calls the key-by-key robotiumUtils function, with an insert index
	 * after_text_key:6702330,this,3,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * after_text_key:time,text,startposition,beforechars,countchars,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @param insertIndex insertion index
	 * @param text text to enter
	 * @throws IOException if the template file can't be read
	 */
	public void writeEnterTextByKey(List<String> tokens, List<LineAndTokens> lines, int insertIndex, String text) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "enter text in " + description;
		/* why is this commented out?  Is this written by the caller? Verify and remove if so.
		if (sLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			sLastEventWasWaitForActivity = false;
		} 
		*/
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.EDIT_TEXT_KEY_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.INSERT, Integer.toString(insertIndex));
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.EDIT_TEXT_KEY_INTERNAL_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.INSERT, Integer.toString(insertIndex));
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			String enterTextIDTemplate = writeViewIDCommand(Constants.Templates.EDIT_TEXT_KEY_ID, ref, fullDescription);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.TEXT, text);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.INSERT, Integer.toString(insertIndex));
			lines.add(new LineAndTokens(tokens, enterTextIDTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write an enterText command from the data from the text watcher
	 * after_text:6702330,this,3,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * after_text:time,text,startposition,beforechars,countchars,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeEnterText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String text =  StringUtils.unescapeString(StringUtils.stripQuotes(tokens.get(2)), '\\');
		writeEnterText(tokens, lines, text);
	} 
	/**
	 * same, except that the text is passed explicitly
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	
	public void writeEnterText(List<String> tokens, List<LineAndTokens> lines, String text) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "enter text in " + description;
		/* why is this commented out?  Is this written by the caller? Verify and remove if so.
		if (sLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			sLastEventWasWaitForActivity = false;
		} 
		*/
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.EDIT_TEXT_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewInternalClassIndexCommand(Constants.Templates.EDIT_TEXT_INTERNAL_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			String enterTextIDTemplate = writeViewIDCommand(Constants.Templates.EDIT_TEXT_ID, ref, fullDescription);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextIDTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * wait for a list element, where the list is referenced by class and index.
	 * @param tokens
	 * @param itemIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeWaitForListClassIndex(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_LIST_CLASS_INDEX, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	/**
	 * wait for a list element, where the list is referenced by class and index.
	 * @param tokens
	 * @param itemIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeWaitForListInternalClassIndex(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_LIST_INTERNAL_CLASS_INDEX, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	
	/**
	 * List items need a wait for the selected item, not just the list.
	 * @param tokens tokens from the select item call
	 * @param itemIndex index of selected item
	 * @param lines output lines.
	 * @throws IOException
	 */
	public void writeWaitForListIdItem(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_LIST_ID_ITEM, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	/**
	 * write the item click event for a list item
	 * TODO: THIS NEEDS TO HANDLE ID AND INTERNAL CLASS INDEX
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String itemClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write the item click event for a menu popup list item
	 * same as item_click event, but we want to differentiate.
	 * menu_item_click:153346865,2,class_index,android.widget.ListPopupWindow$DropDownListView,0,Edit
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writePopupMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			String itemClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}

	/**
	 * write the item selected event for a spinner
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemSelected(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "select item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		
		// TODO: we need to expand RobotiumUtils to select a spinner item based on the spinner ID and internal class index
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			int classIndex = ref.getIndex();
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.SELECT_SPINNER_ITEM, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.SPINNER_INDEX, Integer.toString(classIndex));
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		mViewVariableIndex++;	
	}
	
	/**
	 * child_click:105261255,0,0,class_index,android.widget.ExpandableListView,0,Arnold
	 */
	public void writeChildClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "child click item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String childClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_EXPANDABLE_LIST_CHILD_CLASS_INDEX, ref, fullDescription);
			childClickTemplate = childClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, childClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String childClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_EXPANDABLE_LIST_INTERNAL_CHILD_CLASS_INDEX, ref, fullDescription);
			childClickTemplate = childClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, childClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String childClickTemplate = writeViewIDCommand(Constants.Templates.CLICK_EXPANDABLE_LIST_CHILD_ID, ref, fullDescription);
			childClickTemplate = childClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, childClickTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		mViewVariableIndex++;			
	}
	
	/**
	 * group_click:105266794,1,class_index,android.widget.ExpandableListView,0,Dog Names
	 */
	public void writeGroupClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "group click item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		String groupClickTemplate = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			groupClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_EXPANDABLE_LIST_GROUP_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			groupClickTemplate = writeViewInternalClassIndexCommand(Constants.Templates.CLICK_EXPANDABLE_LIST_GROUP_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			groupClickTemplate = writeViewIDCommand(Constants.Templates.CLICK_EXPANDABLE_LIST_GROUP_ID, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		groupClickTemplate = groupClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, groupClickTemplate));
		mViewVariableIndex++;			
		
	}

	
	/**
	 * write the header on the first activity
	 * @param testPackage com.package.name for the test application
	 * @param testClassName classNameTest<index>
	 * @param className name of the test application
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeHeader(String classPath, String testPackage, String testClassName, String className, BufferedWriter bw) throws IOException {
		String header = FileUtility.readTemplate(Constants.Templates.HEADER);
		header = header.replace(Constants.VariableNames.TESTPACKAGE, testPackage);
		header = header.replace(Constants.VariableNames.CLASSPATH, classPath);
		header = header.replace(Constants.VariableNames.CLASSNAME, className);
		header = header.replace(Constants.VariableNames.TESTCLASSNAME, testClassName);
		bw.write(header);
	}
		
	/**
	 * write the trailer on completion.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write the trailer on completion (split function.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeClassTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.CLASS_TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write a list of lines to a file
	 * @param bw BufferedWriter
	 * @param lines list of lines
	 * @throws IOException
	 */
	public void writeLines(BufferedWriter bw, List<LineAndTokens> lines) throws IOException {
		for (LineAndTokens line : lines) {
			bw.write(line.mOutputLine);
		}
	}
	/**
	 * utility function to write out commands which are based on the view ID for the view reference
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	public String writeViewIDCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.ID, ref.getID());
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		return template;
	}
	/**
	 * same as writeViewIDCommand, except for views referenced by a class and index.
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	
	public String writeViewClassIndexCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		template = template.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(ref.getIndex()));
		return template;
	}
	
	public String writeViewInternalClassIndexCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		template = template.replace(Constants.VariableNames.INTERNAL_CLASS, ref.getInternalClassName());
		template = template.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(ref.getIndex()));
		return template;
	}
	
	/**
	 * on_page_finshed:56051503,id,com.example.android.apis.R$id.wv10,android.webkit.WebView,WebView,url
	 */
	public void waitForPageToLoad(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String template = "";
		String url = tokens.get(6);
		String fullDescription = "wait for URL " + url;
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			template = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			template = writeViewInternalClassIndexCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_INTERNAL_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			template = writeViewIDCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_ID, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		template = template.replace(Constants.VariableNames.URL, url);
		lines.add(new LineAndTokens(tokens, template));
	}
	
	/**
	 * touch_down:20903880,720,176,139.80583,102.80562,id,0x7f0900a2,android.widget.Gallery,Gallery
	 * @param tokens
	 * @param motionEvents
	 */
	public void writeMotionEvents(List<String> 			tokens, 
								  String				nextLine,
								  String 				testClassName, 
								  BufferedReader 		br, 
								  List<MotionEventList> motionEvents, 
								  List<LineAndTokens> lines) throws IOException, EmitterException {
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			mLastEventWasWaitForActivity = false;
		} 
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String uniqueName = (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) ? ref.getID() : (ref.getClassName() + ref.getIndex());
		String name = uniqueName + "_MotionEvents" + Integer.toString(mMotionEventVariableIndex);
		MotionEventList motionEventList = new MotionEventList(name, tokens, nextLine, br);
		motionEvents.add(motionEventList);
		ReferenceParser refEvents = motionEventList.getRef();
		String fullDescription = "play back motion events";
		String template = null;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			template = writeViewIDCommand(Constants.Templates.PLAYBACK_MOTION_EVENTS, refEvents, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			template = writeViewClassIndexCommand(Constants.Templates.PLAYBACK_MOTION_EVENTS_CLASS_INDEX, refEvents, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.INTERNAL_CLASS_INDEX) {
			template = writeViewInternalClassIndexCommand(Constants.Templates.PLAYBACK_MOTION_EVENTS_INTERNAL_CLASS_INDEX, refEvents, fullDescription);
		}
		template = template.replace(Constants.VariableNames.MOTION_EVENT_VARIABLE_INDEX, Integer.toString(mMotionEventVariableIndex));
		template = template.replace(Constants.VariableNames.TESTCLASSNAME, testClassName);
		template = template.replace(Constants.VariableNames.UNIQUE_NAME, uniqueName);
		lines.add(new LineAndTokens(tokens, template));
		mMotionEventVariableIndex++;
	}
	
	/**
	 * write out the lines into the handler for an interstitial activity
	 * @param bw buffered writer
	 * @param testPackageName output package
	 * @param activityName name of the interstitialActivityHandler
	 * @param lines output lines from emit()
	 * @throws IOException
	 */
	
	public void writeInterstitialHandler(BufferedWriter 		bw, 
										 String 				testPackageName,
										 String 				activityName, 
										 List<LineAndTokens> 	lines) throws IOException {
		String header = FileUtility.readTemplate(Constants.Templates.INTERSTITIAL_HEADER);
		header = header.replace(Constants.VariableNames.TESTPACKAGE, testPackageName);
		header = header.replace(Constants.VariableNames.TESTCLASSNAME, activityName);
		bw.write(header);
		for (LineAndTokens line : lines) {
			bw.write(line.mOutputLine);
		}
		String trailer = FileUtility.readTemplate(Constants.Templates.TRAILER);
		bw.write(trailer);
	}

}
