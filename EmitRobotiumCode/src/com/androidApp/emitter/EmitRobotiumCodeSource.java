package com.androidApp.emitter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import com.androidApp.emitter.IEmitCode.LineAndTokens;
import com.androidApp.parser.ProjectPropertiesScan;
import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * @author Matthew
 * Copyright (c) 2013 Matthew Reynolds.  All Rights Reserved.
 * TODO: All Events MUST respect mLastEventWasWaitForActivity, not just click
 * TODO: add mLastEventWasCreateDialog for the same thing
 */
public class EmitRobotiumCodeSource implements IEmitCode {
	protected int mViewVariableIndex = 0;					// incremented for unique view variable names
	protected int mActivityVariableIndex = 0;				// incremented for unique activity variable names
	protected int mMotionEventVariableIndex = 0;			// incremented for unique motion event file names
	protected String mTargetClassPath = null;				// class path of initial activity.	
	protected String mTargetPackage = null;					// package name that the recorder pulled from the app
	private boolean mLastEventWasWaitForActivity = false;	// want to do a waitForView for next event.
		
	public EmitRobotiumCodeSource() {
	}
	
		
	/**
	 * return the fully qualified class path of the application under test
	 * @return
	 */
	public String getApplicationClassPath() {
		return mTargetClassPath;
	}
	
	/**
	 * return the class name of the application under test
	 * @return
	 */
	public String getApplicationClassName() {
		if (mTargetClassPath != null) {
			return StringUtils.getNameFromClassPath(mTargetClassPath);
		} else {
			return null;
		}
	}
	
	/**
	 * return the package name of the application under test.
	 * @return
	 */
	public String getApplicationPackage() {
		return mTargetPackage;
	}
	
	/**
	 * take the events file name (which may be the reserved word "device", and emit the test code into
	 * an array list of the output code with its associated source tokens
	 * @param emitter the emitter
	 * @param eventsFileName source events file, or device if we pull it from the device.
	 * @return list of test code and source tokens.
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws EmitterException
	 */
	public List<LineAndTokens> generateTestCode(IEmitCode emitter, String eventsFileName, List<MotionEventList> motionEvents) throws FileNotFoundException, IOException, EmitterException {
		List<LineAndTokens> lines = new ArrayList<LineAndTokens>();
		BufferedReader br = new BufferedReader(new FileReader(eventsFileName));
		emitter.emit(br, lines, motionEvents);
		return lines;
	}

	
	/**
	 * actually emit robotium code from a recorded file
	 * TODO: change this so it returns the target class path and class name, not modifying statics
	 * @param br BufferedReader on events.txt file
	 * @param lines output lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	@Override
	public void emit(BufferedReader br, List<LineAndTokens> lines, List<MotionEventList> motionEvents) throws IOException, EmitterException {
		boolean scrollsHaveHappened = false;				// we get a zillion scroll events.  We only care about the last one
		int scrollFirstVisibleItem = 0;						// preserve scroll values so we can apply it on the last scroll.
		int scrollListIndex = 0;							// track the current scroll index to write on the next non-scroll instruction
		List<String> lastTextEntryTokens = null;			// to preserve the last text entry event
		String nextActivityVariable = null;
		String previousActivityVariable = null;		
		String currentActivityName = null;					// to track the activity class name to see if it changes in transitions
		boolean fForwardActivityMatches = false;			// there was a navigation to a new activity with the same class name
		boolean fBackActivityMatches = false;				// there was a navigation to a previous activity with the same class name
		boolean	fWasSpinner = false;						// for following item_selected event, the list was a spinner, not a ListView
		String line = br.readLine();	
		int lineNumber = 0;									// track line number for errors
		do {
			if (line == null) {
				break;
			}
			lineNumber++;
			try {
				String nextLine = br.readLine();
				// syntax is event:time,arguments,separated,by,commas
				SuperTokenizer st = new SuperTokenizer(line, "\"", ":,", '\\');
				List<String> tokens = st.toList();
				
				// we peek at the next line to see if it's an activity_forward or an activity back, and save the activity name so it can be 
				// waited for.
				List<String> nextTokens = null;
				if (nextLine != null) {
					SuperTokenizer stNext = new SuperTokenizer(nextLine, "\"", ":,", '\\');
					nextTokens = stNext.toList();
					if (tokens.get(0).equals(Constants.Events.ACTIVITY_FORWARD)) {
						currentActivityName = tokens.get(2);
						if (mTargetClassPath == null) {
							mTargetClassPath =  tokens.get(2);
						}
					}
					if (nextTokens.size() > 2) {
						if (nextTokens.get(0).equals(Constants.Events.ACTIVITY_FORWARD)) {
							String nextActivityName = nextTokens.get(2);
							if (nextActivityName.equals(currentActivityName)) {
								nextActivityVariable = writeGetCurrentActivity(tokens, lines);
								fForwardActivityMatches = true;
							} else {
								fForwardActivityMatches = false;
							}
							currentActivityName = nextActivityName;
						} 
						if (nextTokens.get(0).equals(Constants.Events.ACTIVITY_BACK) || nextTokens.get(0).equals(Constants.Events.ACTIVITY_BACK_KEY)) {
							String previousActivityName = nextTokens.get(2);
							if (previousActivityName.equals(currentActivityName)) {
								previousActivityVariable = writeGetPreviousActivity(tokens, lines);
								fBackActivityMatches = true;
							} else {
								fBackActivityMatches = false;
							}
							currentActivityName = previousActivityName;
						}
					}
				}
				String action = tokens.get(0);
				
				// when the recorder scrolls, it writes out a scroll message for each move, but
				// we just want robotium to issue a single scroll command, so once we read a scroll
				// command, we wait until a scroll happens on another listview, or a different event
				// has occurred, and we scroll to the last list item that was recorded.
				if (scrollsHaveHappened) {
					if (!action.equals(Constants.Events.SCROLL)) {
						writeScroll(scrollListIndex, scrollFirstVisibleItem, tokens, lines);
						scrollsHaveHappened = false;
					} else {
						// scroll:195758909,0,11,11,class_index,android.widget.ListView,1
						// command:time,firstVisible,visibleItemCount,totalItemCount,[view reference]
						int scrollListIndexTest = Integer.parseInt(tokens.get(7));
						if (scrollListIndexTest != scrollListIndex) {
							writeScroll(scrollListIndex, scrollFirstVisibleItem, tokens, lines);
							scrollsHaveHappened = false;
						}
					}
				}
				
				// since the recorder spews TextWatcher events after each key press, we're really only interested
				// in the last one. We detect it by saving each event, then writing it out when either a non-textwatcher
				// event comes in or a textwatcher event on a different view.
				if (!action.equals(Constants.Events.AFTER_TEXT) && !action.equals(Constants.Events.BEFORE_TEXT) && (lastTextEntryTokens != null)) {
					writeEnterText(lastTextEntryTokens, lines);
					lastTextEntryTokens = null;
				}
				
				
				// then everything else is switched on the event name.
				if (action.equals(Constants.Events.PACKAGE)) {
					mTargetPackage = tokens.get(2);
				} else if (action.equals(Constants.Events.ACTIVITY_FORWARD)) {
					if (mTargetClassPath == null) {
						mTargetClassPath = tokens.get(2);
					}
					if (nextActivityVariable != null) {
						mLastEventWasWaitForActivity = true;
						if (fForwardActivityMatches) {
							writeWaitForMatchingActivity(nextActivityVariable, tokens, lines);
						} else {
							writeWaitForActivity(tokens, lines);
						}
					}
				} else if (action.equals(Constants.Events.ACTIVITY_BACK)) {
					
					// I think this is technically incorrect, since the "back" event doesn't always happen from the back key
					// but some other event like a click, and we should use a different template
					if ((tokens.size() > 2) && fBackActivityMatches) {
						writeGoBackToMatchingActivity(previousActivityVariable, tokens, lines);
					} else {
						// TODO: ALWAYS CHECK ACTVITIY, NEVER JUST GO BACK
						writeGoBack(tokens, lines);
					}
					mLastEventWasWaitForActivity = true;
				} else if (action.equals(Constants.Events.ACTIVITY_BACK_KEY)) {
					if ((tokens.size() > 2) && fBackActivityMatches) {
						writeGoBackToMatchingActivity(previousActivityVariable, tokens, lines);
					} else {
						// TODO: ALWAYS CHECK ACTVITIY, NEVER JUST GO BACK
						writeGoBack(tokens, lines);
					}
					mLastEventWasWaitForActivity = true;
				} else {
					if (action.equals(Constants.Events.ITEM_CLICK)) {
						writeItemClick(tokens, lines);
					} else if (action.equals(Constants.Events.POPUP_MENU_ITEM_CLICK)) {
						writePopupMenuItemClick(tokens, lines);
					} else if (action.equals(Constants.Events.ITEM_SELECTED)) {
						writeItemSelected(tokens, lines);
						fWasSpinner = false;
					} else if (action.equals(Constants.Events.SCROLL)) {
						scrollFirstVisibleItem = Integer.parseInt(tokens.get(2));
						scrollsHaveHappened = true;
						scrollListIndex = Integer.parseInt(tokens.get(7));
					} else if (action.equals(Constants.Events.CLICK)) {
						writeClick(tokens, lines);
					} else if (action.equals(Constants.Events.DISMISS_DIALOG)) {
						fWasSpinner = false;
						writeDismissDialog(tokens, lines);
					} else if (action.equals(Constants.Events.CANCEL_DIALOG)) {
						fWasSpinner = false;
						writeCancelDialog(tokens, lines);
					} else if (action.equals(Constants.Events.CREATE_DIALOG)) {
						writeCreateDialog(tokens, lines);
					} else if (action.equals(Constants.Events.SHOW_IME)) {
						writeShowIME(tokens, lines);
					} else if (action.equals(Constants.Events.HIDE_IME)) {
						writeHideIME(tokens, lines);
					} else if (action.equals(Constants.Events.AFTER_TEXT)) {
						if (lastTextEntryTokens != null) {
							ReferenceParser lastViewRef = new ReferenceParser(lastTextEntryTokens, 6);
							ReferenceParser currentViewRef = new ReferenceParser(tokens, 6);
							if (!currentViewRef.equals(lastViewRef)) {
								writeEnterText(lastTextEntryTokens, lines);
							}	
						}
						lastTextEntryTokens = tokens;
					} else if (action.equals(Constants.Events.DISMISS_AUTOCOMPLETE_DROPDOWN)) {
						writeDismissAutoCompleteDropdown(tokens, lines);
					} else if (action.equals(Constants.Events.CREATE_SPINNER_POPUP_WINDOW)) {
						fWasSpinner = true;
					} else if (action.equals(Constants.Events.CREATE_SPINNER_POPUP_DIALOG)) {
						fWasSpinner = true;
					} else if (action.equals(Constants.Events.DISMISS_POPUP_WINDOW_BACK_KEY)) {
						writeDismissPopupWindowBackKey(tokens, lines);
					} else if (action.equals(Constants.Events.DISMISS_SPINNER_DIALOG_BACK_KEY)) {
						writeGoBack(tokens, lines);
						writeDismissDialog(tokens,lines);
					} else if (action.equals(Constants.Events.ROTATION)) {
						writeRotation(tokens, lines);
					} else if (action.equals(Constants.Events.MENU_ITEM_CLICK)) {
						writeMenuItemClick(tokens, lines);
					} else if (action.equals(Constants.Events.EXCEPTION)) {
						writeException(tokens, lines);
					} else if (action.equals(Constants.Events.SELECT_ACTIONBAR_TAB)) {
						selectActionBarTab(tokens, lines);
					} else if (action.equals(Constants.Events.ON_PAGE_FINISHED)) {
						waitForPageToLoad(tokens, lines);
					} else if (action.equals(Constants.Events.TOUCH_DOWN)) {
						writeMotionEvents(tokens, br, motionEvents);
					}
				}
				line = nextLine;
			} catch (Exception ex) {
				System.err.println("error parsing line " + lineNumber);
				System.err.println("line = " + line);
				ex.printStackTrace();
				System.exit(-1);
			}
		} while (true);
	}
	
	/**
	 * the description is written as the last token
	 * @param lines
	 */
	public String getDescription(List<String> tokens) {
		return tokens.get(tokens.size() - 1);
	}
	
	/**
	 * write the test function header
	 * @param bw output writer
	 * @throws IOException if the function header template can't be read
	 */
	public void writeFunctionHeader(BufferedWriter bw) throws IOException {
		String testFunction = FileUtility.readTemplate(Constants.Templates.TEST_FUNCTION);
		bw.write(testFunction);
	}
	
	/**
	 * write the exception and its description
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeException(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String exceptionTemplate = FileUtility.readTemplate(Constants.Templates.EXCEPTION);
		String description = tokens.get(2);
		exceptionTemplate = exceptionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		lines.add(new LineAndTokens(tokens, exceptionTemplate));				
	}
	
	/**
	 * write the select action bar event select_actionbar_tab:90167820,0,Select tab earth
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void selectActionBarTab(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String selectActionBarTabTemplate = FileUtility.readTemplate(Constants.Templates.SELECT_ACTIONBAR_TAB);
		String tabIndex = tokens.get(2);
		String description = tokens.get(3);
		selectActionBarTabTemplate = selectActionBarTabTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		selectActionBarTabTemplate = selectActionBarTabTemplate.replace(Constants.VariableNames.TAB_INDEX, tabIndex);
		lines.add(new LineAndTokens(tokens, selectActionBarTabTemplate));
	}

	/**
	 * write the invokeMenuActionSync() call
	 * @param tokens
	 * @param startIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String menuItemClickTemplate = FileUtility.readTemplate(Constants.Templates.MENU_ITEM_CLICK);
		String menuItemId = tokens.get(2);
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.MENU_ITEM_ID, menuItemId);
		mViewVariableIndex++;
		lines.add(new LineAndTokens(tokens, menuItemClickTemplate));				
	}

	/**
	 * write the getCurrentActivity() call
	 * @param lines
	 * @throws IOException
	 */
	public String writeGetCurrentActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String getCurrentActivityTemplate = FileUtility.readTemplate(Constants.Templates.GET_CURRENT_ACTIVITY);
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.DESCRIPTION, "get the current activity, since the next one has the same class name");
		lines.add(new LineAndTokens(null, getCurrentActivityTemplate));
		String activityName = Constants.Names.ACTIVITY + Integer.toString(mActivityVariableIndex);
		return activityName;
	}

	/**
	 * write the getPreviousActivity() call
	 * @param lines
	 * @throws IOException
	 */
	public String writeGetPreviousActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String getPreviousActivityTemplate = FileUtility.readTemplate(Constants.Templates.GET_PREVIOUS_ACTIVITY);
		getPreviousActivityTemplate = getPreviousActivityTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		getPreviousActivityTemplate = getPreviousActivityTemplate.replace(Constants.VariableNames.DESCRIPTION, "get the previous activity, since the next one has the same class name");
		lines.add(new LineAndTokens(null, getPreviousActivityTemplate));
		String activityName = Constants.Names.ACTIVITY + Integer.toString(mActivityVariableIndex);
		return activityName;
	}
	
	/**
	 * when we send an event to a view just after we do waitForActivity(), some applications (like ApiDemos) use the same activity
	 * with different contents, so it returns immediately, even though the new screen is up.  If there's just been a waitForActivity(), 
	 * then the next view-based event should do a waitForView(), to make sure that the view's actually been shown.
	 * @param tokens parsed from a line in events.txt
	 * @param startIndex starting index of the view reference
	 * @param lines output list of java instructions
	 * 
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForView(List<String> tokens, int startIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, startIndex);
		String description = getDescription(tokens);
		String fullDescription = "wait for view " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String waitForViewTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String waitForClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForClassIndexTemplate));			
		}
		mViewVariableIndex++;
	}
	
	/**
	 * when we go back to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWentBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WENT_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * the application has finished an activity, or set of activities, so we just need to wait for the activity.
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the solo.goBack() call
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBack(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
		lines.add(new LineAndTokens(tokens, goBackTemplate));
	}

	/**
	 * solo.waitForActivity() when we go forward or back to an activity
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * when we go forward to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeWaitForMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_NEW_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the expression for waitForDialogToClose
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeDismissDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCloseTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_CLOSE_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "dismiss dialog " + description;
		waitForDialogCloseTemplate = waitForDialogCloseTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCloseTemplate));
	}
	/**
	 * write the expression for goBack() for a dialog
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeCancelDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCancelTemplate = FileUtility.readTemplate(Constants.Templates.CANCEL_DIALOG_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "cancel dialog " + description;
		waitForDialogCancelTemplate = waitForDialogCancelTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCancelTemplate));
	}
	
	/**
	 * wait for dialogs to be created before interacting with them
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeCreateDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCreateTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_DIALOG_TO_OPEN);
		String description = getDescription(tokens);
		String fullDescription = "cancel dialog " + description;
		waitForDialogCreateTemplate = waitForDialogCreateTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCreateTemplate));
	}
	
	/**
	 * write out the click command:
	 * click:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "click on " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickInViewTemplate =  writeViewIDCommand(Constants.Templates.CLICK_IN_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String clickInClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss_autocomplete_dropdown
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissAutoCompleteDropdown(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "dismiss autocomplete dropdown on " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID)  {
			String dismissDropdownIDTemplate =  writeViewIDCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownIDTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String dismissDropdownClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindow(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindowBackKey(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW_BACK_KEY);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.ACTIVITY_VARIABLE_INDEX, Integer.toString(mActivityVariableIndex++));
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	
	/**
	 * rotation:81589683,90,com.example.android.apis.ApiDemos,com.example.android.apis.ApiDemos@4120f1b0
	 * @param tokens parsed from a line in events.tt
	 * @param lines lines output list of java instructions
	 * @throws IOException if the template file can't be read.
	 * @throws EmitterException
	 */
	public void writeRotation(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String rotationTemplate = FileUtility.readTemplate(Constants.Templates.ROTATE);
		int rotation = 0;
		try {
			rotation = Integer.parseInt(tokens.get(2));
		} catch (NumberFormatException nfex) {
			throw new EmitterException("Rotation value " + tokens.get(2) + " failed to parse");
		}
		
		// TODO: add to constants
		String orientationConstant = "Surface.ROTATION_0";
		if (rotation == 0) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 90) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 180) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 270) {
			orientationConstant = "Surface.ROTATION_0";
		} else {
			throw new EmitterException("Rotation value " + rotation + " is not 0,90,180,270");
		}
		String fullDescription = "rotate the screen " + rotation + " degrees";
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.ORIENTATION, orientationConstant);
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, rotationTemplate));
	}
	
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeShowIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "show IME for " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String showImeViewTemplate = writeViewIDCommand(Constants.Templates.SHOW_IME_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, showImeViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String showImeViewTemplate = writeViewClassIndexCommand(Constants.Templates.SHOW_IME_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, showImeViewTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeHideIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "hide IME for " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String hideImeViewTemplate = writeViewIDCommand(Constants.Templates.HIDE_IME_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, hideImeViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String hideImeClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.HIDE_IME_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, hideImeClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the scroll command for robotium.  This is different because we're not parsing a line, but
	 * rather the last scroll in a continuous list of scroll events.
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeScroll(int scrollListIndex, int scrollFirstVisibleItem, List<String> tokens, List<LineAndTokens> outputLines) throws IOException {
		String scrollListTemplate = FileUtility.readTemplate(Constants.Templates.SCROLL_LIST);
		String description = getDescription(tokens);
		String fullDescription = "scroll down " + description;
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(scrollListIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(scrollFirstVisibleItem));
		mViewVariableIndex++;
		outputLines.add(new LineAndTokens(tokens, scrollListTemplate));
	}
	
	/**
	 * write an enterText command from the data from the text watcher
	 * after_text:6702330,this,3,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * after_text:time,text,startposition,beforechars,countchars,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeEnterText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String text =  StringUtils.unescapeString(StringUtils.stripQuotes(tokens.get(2)), '\\');
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "enter text in " + description;
		/* why is this commented out?  Is this written by the caller? Verify and remove if so.
		if (sLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			sLastEventWasWaitForActivity = false;
		} 
		*/
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.EDIT_TEXT_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			String enterTextIDTemplate = writeViewIDCommand(Constants.Templates.EDIT_TEXT_ID, ref, fullDescription);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextIDTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * wait for a list element, where the list is referenced by class and index.
	 * @param tokens
	 * @param itemIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeWaitForListClassIndex(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_LIST_CLASS_INDEX, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	
	/**
	 * List items need a wait for the selected item, not just the list.
	 * @param tokens tokens from the select item call
	 * @param itemIndex index of selected item
	 * @param lines output lines.
	 * @throws IOException
	 */
	public void writeWaitForListIdItem(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_LIST_ID_ITEM, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	/**
	 * write the item click event for a list item
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write the item click event for a menu popup list item
	 * same as item_click event, but we want to differentiate.
	 * menu_item_click:153346865,2,class_index,android.widget.ListPopupWindow$DropDownListView,0,Edit
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writePopupMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}

	/**
	 * write the item selected event for a spinner
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemSelected(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "select item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			int classIndex = ref.getIndex();
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.SELECT_SPINNER_ITEM, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.SPINNER_INDEX, Integer.toString(classIndex));
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		mViewVariableIndex++;	
	}
	
	
	/**
	 * write the header on the first activity
	 * @param testPackage com.package.name for the test application
	 * @param testClassName classNameTest<index>
	 * @param className name of the test application
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeHeader(String classPath, String testPackage, String testClassName, String className, BufferedWriter bw) throws IOException {
		String header = FileUtility.readTemplate(Constants.Templates.HEADER);
		header = header.replace(Constants.VariableNames.TESTPACKAGE, testPackage);
		header = header.replace(Constants.VariableNames.CLASSPATH, classPath);
		header = header.replace(Constants.VariableNames.CLASSNAME, className);
		header = header.replace(Constants.VariableNames.TESTCLASSNAME, testClassName);
		bw.write(header);
	}
		
	/**
	 * write the trailer on completion.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write the trailer on completion (split function.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeClassTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.CLASS_TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write a list of lines to a file
	 * @param bw BufferedWriter
	 * @param lines list of lines
	 * @throws IOException
	 */
	public void writeLines(BufferedWriter bw, List<LineAndTokens> lines) throws IOException {
		for (LineAndTokens line : lines) {
			bw.write(line.mOutputLine);
		}
	}
	/**
	 * utility function to write out commands which are based on the view ID for the view reference
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	public String writeViewIDCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.ID, ref.getID());
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		return template;
	}
	/**
	 * same as writeViewIDCommand, except for views referenced by a class and index.
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	
	public String writeViewClassIndexCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		template = template.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(ref.getIndex()));
		return template;
	}
	
	/**
	 * on_page_finshed:56051503,id,com.example.android.apis.R$id.wv10,android.webkit.WebView,WebView,url
	 */
	public void waitForPageToLoad(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String template = "";
		String url = tokens.get(6);
		String fullDescription = "wait for URL " + url;
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			int classIndex = ref.getIndex();
			template = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_CLASS_INDEX, ref, fullDescription);
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			template = writeViewIDCommand(Constants.Templates.WAIT_FOR_WEBVIEW_PAGE_ID, ref, fullDescription);
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		template = template.replace(Constants.VariableNames.URL, url);
		lines.add(new LineAndTokens(tokens, template));
	}
	
	/**
	 * touch_down:20903880,720,176,139.80583,102.80562,id,0x7f0900a2,android.widget.Gallery,Gallery
	 * @param tokens
	 * @param motionEvents
	 */
	public void writeMotionEvents(List<String> tokens, BufferedReader br, List<MotionEventList> motionEvents) throws IOException, EmitterException {
		String name = tokens.get(9) + "_MotionEvents" + Integer.toString(mMotionEventVariableIndex);
		mMotionEventVariableIndex++;
		MotionEventList motionEventList = new MotionEventList(name, tokens, br);

	}
}
