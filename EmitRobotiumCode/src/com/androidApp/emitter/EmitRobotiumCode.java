package com.androidApp.emitter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * @author Matthew
 *
 */
public class EmitRobotiumCode {
	protected int mViewVariableIndex = 0;					// incremented for unique variable names
	protected int mActivityVariableIndex = 0;					// incremented for unique variable names
	protected static String sTargetClassPath = null;		// class path of initial activity.	
	protected static String sTargetPackage = null;			// package name that the recorder pulled from the app
	private boolean mLastEventWasWaitForActivity = false;	// want to do a waitForView for next event.
	
	/**
	 * subclass to preserve the tokens that the original line was parsed from for debugging
	 * @author Matthew
	 *
	 */
	public class LineAndTokens {
		public List<String>	mTokens;				// source tokens
		public String		mOutputLine;			// output line from populated template
		
		public LineAndTokens(List<String> tokens, String outputLine) {
			mTokens = tokens;
			mOutputLine = outputLine;
		}
	}
	
	/**
	 * retains parsed options
	 * @author Matthew
	 *
	 */
	public class Options {
		public boolean 	mfWriteFunctions = false;			// write output as functions broken up by activity.
		public int		mMinLines = 5;						// min # of lines in a function		
	}
	
	/**
	 * retains directories
	 */
	public class Dirs {
		public String mSrcDir = null;							// src
		public String mLibDir = null;							// lib
		public String mResDir = null;							// res
		public String mDrawableDir = null;						// res/drawable	
	}
	
	/**
	 * take an input file spit out by the event recorder, and generate robotium code
	 * @param args 4 strings: input file (events.txt), output file test.java, target project name and the robotiumJar file.
	 * the caller has to specify the project name because the .apk file name can be changed, and it actually the name of the 
	 * build project, i.e. made from unobtainium
	 * @throws FileNotFoundException
	 * @throws IOException
	 * @throws EmitterException
	 */
	public static void main(String[] args) throws FileNotFoundException, IOException, EmitterException {
		if (args.length < 3) {
			System.err.println("usage: EmitRobotium [events.txt|device] <target-project-name> <robotium-jar-path>");
			System.err.println("events.txt is the output file from the recorder");
			System.err.println("device pulls the events.txt file from /sdcard/events.txt");
			System.err.println("<target-project-name> is the name of the project to instrument via robotium");
			System.err.println("if <target-project-name> directory exists, then the output code will be written into");
			System.err.println("a new file with a numeric suffix, e.g. ApiDemosTest1.java");
			System.err.println("<robotium-jar-path> path to the robotium jar file (download it from http://code.google.com/p/robotium/downloads/list)");
			System.err.println("--splitFunctions splits the output into functions bracketed by activities");
			System.err.println("--minLines <min-lines> minimum # of lines of code in a function (default: 5) ");
			System.exit(-1);
		}
		String eventsFileName = args[0];
		String targetProject = args[1];
		String robotiumJarPath = args[2];
		String outputCodeFileName = Constants.Filenames.OUTPUT;
		EmitRobotiumCode emitter = new EmitRobotiumCode();

		Options options = emitter.processOptions(args);
		
		File robotiumFile = new File(robotiumJarPath);
		List<LineAndTokens> lines = new ArrayList<LineAndTokens>();
		String robotiumJar = robotiumFile.getName();
		
		// if he specified device, use adb to pull the events file off the device.
		if (eventsFileName.equals(Constants.Names.DEVICE)) {
	       Process proc = null;
	       String cmd = "adb pull /sdcard/events.txt";
	       try {
	            proc = Runtime.getRuntime().exec(cmd);
	        } catch (IOException e) {
	            System.err.println("failed to execute " + cmd + " " + e.getMessage());
	            System.exit(-1);
	        }
	        try {
	            int result = proc.waitFor();
	        } catch (InterruptedException e) {
	            System.err.println("interrupted executing " + cmd + " " + e.getMessage());
	            System.exit(-1);
	        }
	        eventsFileName = "events.txt";
		}
		BufferedReader br = new BufferedReader(new FileReader(eventsFileName));
		BufferedWriter bw = new BufferedWriter(new FileWriter(outputCodeFileName));
		emitter.emit(br, lines);
		if (emitter.getApplicationClassPath() == null) {
			System.err.println("unable to generate output code, no activity reference");
			System.exit(-1);
		}
		String testClassPath = emitter.getApplicationClassPath() + Constants.Extensions.TEST;
		
		// generated test class name
		String testClassName = emitter.getApplicationClassName() + Constants.Extensions.TEST;
		String srcdirname = testClassName + File.separator + Constants.Dirs.SRC;
		String packageFilePath = srcdirname + File.separator + FileUtility.sourceDirectoryFromClassName(testClassPath);
		String templateFileName = testClassName + "." + Constants.Extensions.JAVA;
		int uniqueFileIndex = FileUtility.uniqueFileIndex(packageFilePath, templateFileName);
		if (uniqueFileIndex != 0) {
			testClassPath += Integer.toString(uniqueFileIndex);
			testClassName += Integer.toString(uniqueFileIndex) ;
		}
		writeHeader(emitter.getApplicationClassPath(), testClassName, emitter.getApplicationClassName(), bw);
		if (options.mfWriteFunctions) {
			SplitFunction splitter = new SplitFunction(options.mMinLines);
			splitter.writeFunctions(bw, "test" + targetProject, 0, lines);
			writeClassTrailer(bw);
		} else {
			String testFunction = FileUtility.readTemplate(Constants.Templates.TEST_FUNCTION);
			bw.write(testFunction);
			EmitRobotiumCode.writeLines(bw, lines);
			writeTrailer(bw);
		}
		
		bw.close();
		br.close();
		if (emitter.getApplicationClassPath() != null) {
			if (uniqueFileIndex == 0) {
				Dirs dirs = emitter.createDirectories(testClassName, packageFilePath);
				generateBuildXML(testClassName, emitter.getApplicationClassPath());
				copyBuildFiles(testClassName);
				copyLibrary(dirs.mLibDir);
				generateManifest(testClassName, testClassName, testClassPath, emitter.getApplicationPackage());
				copyTestDriverFile(packageFilePath, emitter.getApplicationClassPath());
				writeResources(dirs, testClassName);
				writeClasspath(testClassName, targetProject, robotiumJar);
				FileUtility.copyFile(robotiumFile.getPath(), testClassName + File.separator + Constants.Dirs.LIBS + File.separator + robotiumJar);
			}
			moveOutputCodeToPackage(packageFilePath, outputCodeFileName, testClassName);
		} else {
			System.err.println("no activity class specified");
		}
	}
	
	public EmitRobotiumCode() {
	}
	
	/**
	 * process the options into flags and values.
	 * @param args
	 */
	public Options processOptions(String[] args) {
		Options options = new Options();
		for (int i = 0; i < args.length; i++) {
			String arg = args[i];
			if (arg.equals("--splitFunctions")) {
				options.mfWriteFunctions = true;
			} else if (args.equals("--minLines")) {
				options.mMinLines = Integer.parseInt(args[i + 1]);
			}
		}
		return options;
	}
	
	/**
	 * return the fully qualified class path of the application under test
	 * @return
	 */
	public String getApplicationClassPath() {
		return sTargetClassPath;
	}
	
	/**
	 * return the class name of the application under test
	 * @return
	 */
	public String getApplicationClassName() {
		if (sTargetClassPath != null) {
			return StringUtils.getNameFromClassPath(sTargetClassPath);
		} else {
			return null;
		}
	}
	
	/**
	 * return the package name of the application under test.
	 * @return
	 */
	public String getApplicationPackage() {
		return sTargetPackage;
	}
	
	/**
	 * create the directories required by the test project
	 * src - source directory
	 * src/path/to/test/java/package - directory that the java file is actually written into
	 * res - resources directory
	 * res/drawable - directory for icons and stuff
	 * res/values - directory for strings and stuff
	 * libs - directory for libraries (specifically the robotium jar)
	 * @param dirname name of the output test class (also the name of the project)
	 * @param testClassFilePath full path directory to output test class files
	 */
	public Dirs createDirectories(String dirname, String testClassFilePath) throws IOException {
		Dirs dirs = new Dirs();
		boolean fOK = true;
		dirs.mSrcDir = dirname + File.separator + Constants.Dirs.SRC;
		File packageDir = new File(testClassFilePath);
		fOK = packageDir.mkdirs();
		dirs.mLibDir = dirname + File.separator + Constants.Dirs.LIBS;
		File libdir = new File(dirs.mLibDir);
		fOK &= libdir.mkdirs();
		dirs.mResDir = dirname + File.separator + Constants.Dirs.RES;
		File resdir = new File(dirs.mResDir);
		fOK &= resdir.mkdir();
		dirs.mDrawableDir = resdir.getPath() + File.separator + Constants.Dirs.DRAWABLE;
		File drawabledir = new File(dirs.mDrawableDir);
		fOK &= drawabledir.mkdir();
		return dirs;
	}
	
	/**
	 * copy the output file to the package, since we don't know the package name until we've read the first activity
	 * @param packageDir output package directory src/com/foo/barTest
	 * @param outputCodeFileName argv[1]
	 * @param packagePath class name of the test class
	 * @throws EmitterException if the file can't be moved
	 */
	public static void moveOutputCodeToPackage(String packageDir, String outputCodeFileName, String testClassName) throws EmitterException {
		File sourceFile = new File(outputCodeFileName);
		String destinationPath = packageDir + File.separator + testClassName + "." + Constants.Extensions.JAVA;
		if (!sourceFile.renameTo(new File(destinationPath))) {
			throw new EmitterException("failed to rename " + sourceFile.getPath() + " to " + destinationPath);
		}
	}
	
	/**
	 * generate the .classpath file for building the project.  We  add the target project name
	 * for eclipse/ant, and the robotium jar in the libs directory.
	 * @param dirname directory that the .classpath file is written into
	 * @param projectName name of the target project
	 * @param name of the robotium-solo-X.XX.jar
	 * @throws IOException if the file can't be written
	 */
	public static void writeClasspath(String dirname, String projectName, String robotiumJar) throws IOException {
		String classpath = FileUtility.readTemplate(Constants.Templates.CLASSPATH);
		classpath = classpath.replace(Constants.VariableNames.TARGET_PROJECT, projectName);
		classpath = classpath.replace(Constants.VariableNames.ROBOTIUM_JAR, robotiumJar);
		String path = dirname + File.separator + Constants.Filenames.CLASSPATH;
		BufferedWriter bw = new BufferedWriter(new FileWriter(path));
		bw.write(classpath);
		bw.close();
	}
	
	/** 
	 * write various resources used by the test application.  We write the icon, but we probably don't have to
	 * @param dirname test project directory
	 * @return true if the resources were written correctly.
	 * @throws IOException
	 */
	public static void writeResources(Dirs dirs, String dirname) throws IOException {
		FileUtility.writeResource(Constants.Filenames.LAUNCHER_PNG, dirs.mDrawableDir);
	}
	
	/**
	 * write the AndroidManifest.xml
	 * @param dirname name of the top-level directory to write the manifest into
	 * @param testClassName name of the test class.
	 * @param testClassPath fully.qualified.testClass.path
	 * @param targetPackage package of test class
	 * @throws IOException
	 */
	public static void generateManifest(String dirname, String testClassName, String testClassPath, String targetPackage)throws IOException {
		String manifest = FileUtility.readTemplate(Constants.Templates.ANDROID_MANIFEST_XML); 
		manifest = manifest.replace(Constants.VariableNames.CLASSPATH, testClassPath);
		manifest = manifest.replace(Constants.VariableNames.TARGETPACKAGE, sTargetPackage);
		manifest = manifest.replace(Constants.VariableNames.CLASSNAME, testClassName);
		BufferedWriter bw = new BufferedWriter(new FileWriter(dirname + File.separator + Constants.Filenames.ANDROID_MANIFEST_XML));
		bw.write(manifest);
		bw.close();
	}
	
	/**
	 * replace the variables in the build.xml template and write out the file
	 * @param dirname target top-level directory
	 * @param targetClassPath full class name of application class being tested.
	 * @throws IOException
	 */
	public static void generateBuildXML(String dirname, String targetClassPath) throws IOException {
		String buildXML = FileUtility.readTemplate(Constants.Templates.BUILD_XML);
		String className = StringUtils.getNameFromClassPath(targetClassPath);
		buildXML = buildXML.replace(Constants.VariableNames.CLASSNAME, className);
		BufferedWriter bw = new BufferedWriter(new FileWriter(dirname + File.separator + Constants.Filenames.BUILD_XML));
		bw.write(buildXML);
		bw.close();
	}
	
	/**
	 * write out the project.properties file
	 * @param dirname project directory
	 * @throws IOException
	 */
	public static void copyBuildFiles(String dirname) throws IOException {
		String projectProperties = FileUtility.readTemplate(Constants.Templates.PROJECT_PROPERTIES);
		BufferedWriter bw = new BufferedWriter(new FileWriter(dirname + File.separator + Constants.Filenames.PROJECT_PROPERTIES));
		bw.write(projectProperties);
		bw.close();
	}
	
	/**
	 * write out the AllTests.java to the output class directory src\foo\bar\path
	 * @packagePathName file/path/to/class/output/directory
	 * @param applicationClassPath fully.qualified.path.to.application.under.test
	 * @throws IOException if the template can't be found
	 */
	public static void copyTestDriverFile(String packagePathName, String applicationClassPath) throws IOException {
		String allTests = FileUtility.readTemplate(Constants.Templates.ALL_TESTS);
		allTests = allTests.replace(Constants.VariableNames.CLASSPATH, applicationClassPath);
		BufferedWriter bw = new BufferedWriter(new FileWriter(packagePathName + File.separator + Constants.Filenames.ALL_TESTS));
		bw.write(allTests);
		bw.close();
		
	}
	
	/**
	 * copy support library to the output directory
	 * @param libraryDir libs directory
	 * @throws IOException if the template can't be found
	 */
	public static void copyLibrary(String libraryDir) throws IOException {
		byte[] jarData = FileUtility.readBinaryTemplate(Constants.Filenames.UTILITY_JAR);
		FileOutputStream fos = new FileOutputStream(libraryDir + File.separator + Constants.Filenames.UTILITY_JAR);
		fos.write(jarData, 0, jarData.length);
		fos.close();		
	}
	
	
	/**
	 * actually emit robotium code from a recorded file
	 * TODO: change this so it returns the target class path and class name, not modifying statics
	 * @param br BufferedReader on events.txt file
	 * @param lines output lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void emit(BufferedReader br, List<LineAndTokens> lines) throws IOException, EmitterException {
		boolean scrollsHaveHappened = false;				// we get a zillion scroll events.  We only care about the last one
		int scrollFirstVisibleItem = 0;						// preserve scroll values so we can apply it on the last scroll.
		int scrollListIndex = 0;							// track the current scroll index to write on the next non-scroll instruction
		List<String> lastTextEntryTokens = null;			// to preserve the last text entry event
		String nextActivityVariable = null;
		String previousActivityVariable = null;		
		String line = br.readLine();
		int lineNumber = 0;									// track line number for errors
		do {
			String nextLine = br.readLine();
			if (line == null) {
				break;
			}
			lineNumber++;
			try {
				// syntax is event:time,arguments,separated,by,commas
				SuperTokenizer st = new SuperTokenizer(line, "\"", ":,", '\\');
				List<String> tokens = st.toList();
				
				// we peek at the next line to see if it's an activity_forward or an activity back, and save the activity name so it can be 
				// waited for.
				List<String> nextTokens = null;
				if (nextLine != null) {
					SuperTokenizer stNext = new SuperTokenizer(nextLine, "\"", ":,", '\\');
					nextTokens = stNext.toList();
					if (nextTokens.size() > 2) {
						if (nextTokens.get(0).equals(Constants.Events.ACTIVITY_FORWARD)) {
							nextActivityVariable = writeGetCurrentActivity(nextTokens, lines);
						} 
						if (nextTokens.get(0).equals(Constants.Events.ACTIVITY_BACK) || nextTokens.get(0).equals(Constants.Events.ACTIVITY_BACK_KEY)) {
							previousActivityVariable = writeGetCurrentActivity(nextTokens, lines);
						}
					}
				}
				String action = tokens.get(0);
				
				// when the recorder scrolls, it writes out a scroll message for each move, but
				// we just want robotium to issue a single scroll command, so once we read a scroll
				// command, we wait until a scroll happens on another listview, or a different event
				// has occurred, and we scroll to the last list item that was recorded.
				if (scrollsHaveHappened) {
					if (!action.equals(Constants.Events.SCROLL)) {
						writeScroll(scrollListIndex, scrollFirstVisibleItem, tokens, lines);
						scrollsHaveHappened = false;
					} else {
						// scroll:195758909,0,11,11,class_index,android.widget.ListView,1
						// command:time,firstVisible,visibleItemCount,totalItemCount,[view reference]
						int scrollListIndexTest = Integer.parseInt(tokens.get(7));
						if (scrollListIndexTest != scrollListIndex) {
							writeScroll(scrollListIndex, scrollFirstVisibleItem, tokens, lines);
							scrollsHaveHappened = false;
						}
					}
				}
				
				// since the recorder spews TextWatcher events after each key press, we're really only interested
				// in the last one. We detect it by saving each event, then writing it out when either a non-textwatcher
				// event comes in or a textwatcher event on a different view.
				if (!action.equals(Constants.Events.AFTER_TEXT) && !action.equals(Constants.Events.BEFORE_TEXT) && (lastTextEntryTokens != null)) {
					writeEnterText(lastTextEntryTokens, lines);
					lastTextEntryTokens = null;
				}
				
				
				// then everything else is switched on the event name.
				if (action.equals(Constants.Events.PACKAGE)) {
					sTargetPackage = tokens.get(2);
				} else if (action.equals(Constants.Events.ACTIVITY_FORWARD) && (nextActivityVariable != null)) {
					if (sTargetClassPath == null) {
						sTargetClassPath = tokens.get(2);
					}
					mLastEventWasWaitForActivity = true;
					writeWaitForMatchingActivity(nextActivityVariable, tokens, lines);
				} else if (action.equals(Constants.Events.ACTIVITY_BACK)) {
					
					// I think this is technically incorrect, since the "back" event doesn't happen from the back key
					// but some other event like a click, and we should use a different template
					writeGoBackToMatchingActivity(previousActivityVariable, tokens, lines);
					mLastEventWasWaitForActivity = true;
				} else if (action.equals(Constants.Events.ACTIVITY_BACK_KEY)) {
					writeGoBackToMatchingActivity(previousActivityVariable, tokens, lines);
					mLastEventWasWaitForActivity = true;
				} else {
					if (action.equals(Constants.Events.ITEM_CLICK)) {
						writeItemClick(tokens, lines);
					} else if (action.equals(Constants.Events.POPUP_MENU_ITEM_CLICK)) {
						writePopupMenuItemClick(tokens, lines);
					} else if (action.equals(Constants.Events.ITEM_SELECTED)) {
						writeItemSelected(tokens, lines);
					} else if (action.equals(Constants.Events.SCROLL)) {
						scrollFirstVisibleItem = Integer.parseInt(tokens.get(2));
						scrollsHaveHappened = true;
						scrollListIndex = Integer.parseInt(tokens.get(7));
					} else if (action.equals(Constants.Events.CLICK)) {
						writeClick(tokens, lines);
					} else if (action.equals(Constants.Events.DISMISS_DIALOG)) {
						writeDismissDialog(tokens, lines);
					} else if (action.equals(Constants.Events.DISMISS_DIALOG_BACK_KEY)) {
						writeDismissDialogBackKey(tokens, lines);
					} else if (action.equals(Constants.Events.CANCEL_DIALOG)) {
						writeCancelDialog(tokens, lines);
					} else if (action.equals(Constants.Events.SHOW_IME)) {
						writeShowIME(tokens, lines);
					} else if (action.equals(Constants.Events.HIDE_IME)) {
						writeHideIME(tokens, lines);
					} else if (action.equals(Constants.Events.AFTER_TEXT)) {
						if (lastTextEntryTokens != null) {
							ReferenceParser lastViewRef = new ReferenceParser(lastTextEntryTokens, 6);
							ReferenceParser currentViewRef = new ReferenceParser(tokens, 6);
							if (!currentViewRef.equals(lastViewRef)) {
								writeEnterText(lastTextEntryTokens, lines);
							}	
						}
						lastTextEntryTokens = tokens;
					} else if (action.equals(Constants.Events.DISMISS_AUTOCOMPLETE_DROPDOWN)) {
						writeDismissAutoCompleteDropdown(tokens, lines);
					} else if (action.equals(Constants.Events.DISMISS_POPUP_WINDOW)) {
						writeDismissPopupWindow(tokens, lines);
					} else if (action.equals(Constants.Events.DISMISS_POPUP_WINDOW_BACK_KEY)) {
						writeDismissPopupWindowBackKey(tokens, lines);
					} else if (action.equals(Constants.Events.ROTATION)) {
						writeRotation(tokens, lines);
					} else if (action.equals(Constants.Events.MENU_ITEM_CLICK)) {
						writeMenuItemClick(tokens, lines);
					} else if (action.equals(Constants.Events.EXCEPTION)) {
						writeException(tokens, lines);
					}
				}
				line = nextLine;
			} catch (Exception ex) {
				System.err.println("error parsing line " + lineNumber);
				System.err.println("line = " + line);
				ex.printStackTrace();
				System.exit(-1);
			}
		} while (true);
	}
	
	/**
	 * the description is written as the last token
	 * @param lines
	 */
	public static String getDescription(List<String> tokens) {
		return tokens.get(tokens.size() - 1);
	}
	
	/**
	 * write the exception and its description
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 */
	public void writeException(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String exceptionTemplate = FileUtility.readTemplate(Constants.Templates.EXCEPTION);
		String description = tokens.get(2);
		exceptionTemplate = exceptionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		lines.add(new LineAndTokens(tokens, exceptionTemplate));				
	}
	
	

	/**
	 * write the invokeMenuActionSync() call
	 * @param tokens
	 * @param startIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String menuItemClickTemplate = FileUtility.readTemplate(Constants.Templates.MENU_ITEM_CLICK);
		String menuItemId = tokens.get(2);
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		menuItemClickTemplate = menuItemClickTemplate.replace(Constants.VariableNames.MENU_ITEM_ID, menuItemId);
		mViewVariableIndex++;
		lines.add(new LineAndTokens(tokens, menuItemClickTemplate));				
	}

	/**
	 * write the getCurrentActivity() call
	 * @param lines
	 * @throws IOException
	 */
	public String writeGetCurrentActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String getCurrentActivityTemplate = FileUtility.readTemplate(Constants.Templates.GET_CURRENT_ACTIVITY);
		String activityClass = tokens.get(2);
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, activityClass);	
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		getCurrentActivityTemplate = getCurrentActivityTemplate.replace(Constants.VariableNames.DESCRIPTION, "get the current activity, since the next one has the same class name");
		lines.add(new LineAndTokens(null, getCurrentActivityTemplate));
		String activityName = Constants.Names.ACTIVITY + Integer.toString(mActivityVariableIndex);
		return activityName;
	}
	
	/**
	 * when we send an event to a view just after we do waitForActivity(), some applications (like ApiDemos) use the same activity
	 * with different contents, so it returns immediately, even though the new screen is up.  If there's just been a waitForActivity(), 
	 * then the next view-based event should do a waitForView(), to make sure that the view's actually been shown.
	 * @param tokens parsed from a line in events.txt
	 * @param startIndex starting index of the view reference
	 * @param lines output list of java instructions
	 * 
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForView(List<String> tokens, int startIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, startIndex);
		String description = getDescription(tokens);
		String fullDescription = "wait for view " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String waitForViewTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String waitForClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, waitForClassIndexTemplate));			
		}
		mViewVariableIndex++;
	}
	
	/**
	 * when we go back to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWentBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WENT_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * the application has finished an activity, or set of activities, so we just need to wait for the activity.
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * solo.waitForActivity() when we go forward or back to an activity
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * when we go forward to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeWaitForMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.WAIT_FOR_NEW_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the expression for waitForDialogToClose
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeDismissDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCloseTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_BACK_KEY_CLOSE_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "dismiss dialog with back key" + description;
		waitForDialogCloseTemplate = waitForDialogCloseTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCloseTemplate));
	}
	
	/**
	 * write the expression for waitForDialogToClose after the user has hit the back key.
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeDismissDialogBackKey(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCloseTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_CLOSE_TEMPLATE);
		String description = getDescription(tokens);
		String fullDescription = "dismiss dialog " + description;
		waitForDialogCloseTemplate = waitForDialogCloseTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCloseTemplate));
	}
	/**
	 * write the expression for goBack() for a dialog
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeCancelDialog(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitForDialogCancelTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
		String description = getDescription(tokens);
		String fullDescription = "cancel dialog " + description;
		waitForDialogCancelTemplate = waitForDialogCancelTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, waitForDialogCancelTemplate));
	}
	
	/**
	 * write out the click command:
	 * click:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "click on " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 2, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickInViewTemplate =  writeViewIDCommand(Constants.Templates.CLICK_IN_VIEW_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String clickInClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_VIEW_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, clickInClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss_autocomplete_dropdown
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissAutoCompleteDropdown(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "dismiss autocomplete dropdown on " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID)  {
			String dismissDropdownIDTemplate =  writeViewIDCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownIDTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String dismissDropdownClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.DISMISS_AUTOCOMPLETE_DROPDOWN_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, dismissDropdownClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindow(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	/**
	 * write out the dismiss popup window class
	 * @param tokens
	 * @param lines
	 * @throws IOException
	 * @throws EmitterException
	 */
	public void writeDismissPopupWindowBackKey(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String dismissPopupTemplate = FileUtility.readTemplate(Constants.Templates.DISMISS_POPUP_WINDOW_BACK_KEY);
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.ACTIVITY_VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		dismissPopupTemplate = dismissPopupTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		lines.add(new LineAndTokens(tokens, dismissPopupTemplate));
	}
	
	
	/**
	 * rotation:81589683,90,com.example.android.apis.ApiDemos,com.example.android.apis.ApiDemos@4120f1b0
	 * @param tokens parsed from a line in events.tt
	 * @param lines lines output list of java instructions
	 * @throws IOException if the template file can't be read.
	 * @throws EmitterException
	 */
	public void writeRotation(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String rotationTemplate = FileUtility.readTemplate(Constants.Templates.ROTATE);
		int rotation = 0;
		try {
			rotation = Integer.parseInt(tokens.get(2));
		} catch (NumberFormatException nfex) {
			throw new EmitterException("Rotation value " + tokens.get(2) + " failed to parse");
		}
		String orientationConstant = "Surface.ROTATION_0";
		if (rotation == 0) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 90) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 180) {
			orientationConstant = "Surface.ROTATION_0";
		} else if (rotation == 270) {
			orientationConstant = "Surface.ROTATION_0";
		} else {
			throw new EmitterException("Rotation value " + rotation + " is not 0,90,180,270");
		}
		String fullDescription = "rotate the screen " + rotation + " degrees";
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.ORIENTATION, orientationConstant);
		rotationTemplate = rotationTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		lines.add(new LineAndTokens(tokens, rotationTemplate));
	}
	
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeShowIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "show IME for " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String showImeViewTemplate = writeViewIDCommand(Constants.Templates.SHOW_IME_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, showImeViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String showImeClassIndexTemplate = FileUtility.readTemplate(Constants.Templates.SHOW_IME_CLASS_INDEX);
			String showImeViewTemplate = writeViewClassIndexCommand(Constants.Templates.SHOW_IME_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, showImeClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	/**
	 * write out the show ime command:
	 * show_ime:195773901,id,com.example.android.apis.R$id.radio_button
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeHideIME(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		ReferenceParser ref = new ReferenceParser(tokens, 2);
		String description = getDescription(tokens);
		String fullDescription = "hide IME for " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String hideImeViewTemplate = writeViewIDCommand(Constants.Templates.HIDE_IME_ID, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, hideImeViewTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String hideImeClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.HIDE_IME_CLASS_INDEX, ref, fullDescription);
			lines.add(new LineAndTokens(tokens, hideImeClassIndexTemplate));			
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write out the scroll command for robotium.  This is different because we're not parsing a line, but
	 * rather the last scroll in a continuous list of scroll events.
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeScroll(int scrollListIndex, int scrollFirstVisibleItem, List<String> tokens, List<LineAndTokens> outputLines) throws IOException {
		String scrollListTemplate = FileUtility.readTemplate(Constants.Templates.SCROLL_LIST);
		String description = getDescription(tokens);
		String fullDescription = "scroll down " + description;
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(scrollListIndex));
		scrollListTemplate = scrollListTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(scrollFirstVisibleItem));
		mViewVariableIndex++;
		outputLines.add(new LineAndTokens(tokens, scrollListTemplate));
	}
	
	/**
	 * write an enterText command from the data from the text watcher
	 * after_text:6702330,this,3,0,1,id,com.example.android.apis.R$id.edit,android.widget.AutoCompleteTextView
	 * after_text:time,text,startposition,beforechars,countchars,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeEnterText(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		String text =  StringUtils.unescapeString(StringUtils.stripQuotes(tokens.get(2)), '\\');
		ReferenceParser ref = new ReferenceParser(tokens, 6);
		String description = getDescription(tokens);
		String fullDescription = "enter text in " + description;
		/* why is this commented out?  Is this written by the caller? Verify and remove if so.
		if (sLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 6, lines);
			sLastEventWasWaitForActivity = false;
		} 
		*/
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String enterTextClassIndexTemplate = writeViewClassIndexCommand(Constants.Templates.EDIT_TEXT_CLASS_INDEX, ref, fullDescription);
			enterTextClassIndexTemplate = enterTextClassIndexTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextClassIndexTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String id = ref.getID();
			String enterTextIDTemplate = writeViewIDCommand(Constants.Templates.EDIT_TEXT_ID, ref, fullDescription);
			enterTextIDTemplate = enterTextIDTemplate.replace(Constants.VariableNames.TEXT, text);
			lines.add(new LineAndTokens(tokens, enterTextIDTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * wait for a list element, where the list is referenced by class and index.
	 * @param tokens
	 * @param itemIndex
	 * @param lines
	 * @throws IOException
	 */
	public void writeWaitForListClassIndex(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewClassIndexCommand(Constants.Templates.WAIT_FOR_LIST_CLASS_INDEX, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	
	/**
	 * List items need a wait for the selected item, not just the list.
	 * @param tokens tokens from the select item call
	 * @param itemIndex index of selected item
	 * @param lines output lines.
	 * @throws IOException
	 */
	public void writeWaitForListIdItem(List<String> tokens, int itemIndex, List<LineAndTokens> lines) throws IOException {
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String fullDescription = "select item " + itemIndex + " in " + getDescription(tokens);
		String listItemWaitTemplate = writeViewIDCommand(Constants.Templates.WAIT_FOR_LIST_ID_ITEM, ref, fullDescription);
		listItemWaitTemplate = listItemWaitTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
		lines.add(new LineAndTokens(tokens, listItemWaitTemplate));				
	}
	/**
	 * write the item click event for a list item
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}
	
	/**
	 * write the item click event for a menu popup list item
	 * same as item_click event, but we want to differentiate.
	 * menu_item_click:153346865,2,class_index,android.widget.ListPopupWindow$DropDownListView,0,Edit
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writePopupMenuItemClick(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "click item " + description;
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.CLICK_IN_LIST, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else if (ref.getReferenceType() == ReferenceParser.ReferenceType.ID) {
			String clickListItemTemplate = writeViewIDCommand(Constants.Templates.CLICK_LIST_ITEM, ref, fullDescription);
			clickListItemTemplate = clickListItemTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, clickListItemTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
	}

	/**
	 * write the item selected event for a spinner
	 * item_click:195768219, 2,class_index,android.widget.ListView,1
	 * command:time,item_index,[view reference]
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeItemSelected(List<String> tokens, List<LineAndTokens> lines) throws IOException, EmitterException {
		int itemIndex = Integer.parseInt(tokens.get(2)) + 1;
		ReferenceParser ref = new ReferenceParser(tokens, 3);
		String description = getDescription(tokens);
		String fullDescription = "select item " + description;
		if (mLastEventWasWaitForActivity) {
			writeWaitForView(tokens, 3, lines);
			mLastEventWasWaitForActivity = false;
		} 
		if (ref.getReferenceType() == ReferenceParser.ReferenceType.CLASS_INDEX) {
			int classIndex = ref.getIndex();
			String itemClickTemplate = writeViewClassIndexCommand(Constants.Templates.SELECT_SPINNER_ITEM, ref, fullDescription);
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.SPINNER_INDEX, Integer.toString(classIndex));
			itemClickTemplate = itemClickTemplate.replace(Constants.VariableNames.ITEM_INDEX, Integer.toString(itemIndex));
			lines.add(new LineAndTokens(tokens, itemClickTemplate));
		} else {
			throw new EmitterException("bad view reference while trying to parse " + StringUtils.concatStringList(tokens, " "));
		}
		mViewVariableIndex++;	
	}
	
	
	/**
	 * write the header on the first activity
	 * @param classPath com.package.name for the test application
	 * @param testClassName classNameTest<index>
	 * @param className name of the test application
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public static void writeHeader(String classPath, String testClassName, String className, BufferedWriter bw) throws IOException {
		String header = FileUtility.readTemplate(Constants.Templates.HEADER);
		header = header.replace(Constants.VariableNames.CLASSPATH, classPath);
		header = header.replace(Constants.VariableNames.CLASSPACKAGE, classPath);
		header = header.replace(Constants.VariableNames.CLASSNAME, className);
		header = header.replace(Constants.VariableNames.TESTCLASSNAME, testClassName);
		bw.write(header);
	}
	
	/**
	 * write the trailer on completion.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public static void writeTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write the trailer on completion (split function.
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public static void writeClassTrailer(BufferedWriter bw) throws IOException {
		String trailer = FileUtility.readTemplate(Constants.Templates.CLASS_TRAILER);
		bw.write(trailer);
	}
	
	/**
	 * write a list of lines to a file
	 * @param bw BufferedWriter
	 * @param lines list of lines
	 * @throws IOException
	 */
	public static void writeLines(BufferedWriter bw, List<LineAndTokens> lines) throws IOException {
		for (LineAndTokens line : lines) {
			bw.write(line.mOutputLine);
		}
	}
	/**
	 * utility function to write out commands which are based on the view ID for the view reference
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	public String writeViewIDCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.ID, ref.getID());
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		return template;
	}
	/**
	 * same as writeViewIDCommand, except for views referenced by a class and index.
	 * @param templateFile name of template file from template resources with %VARIABLE_NAMES% to replace.
	 * @param ref view reference (by view ID)
	 * @param fullDescription put this in the comment
	 * @return filled out template
	 * @throws IOException
	 */
	
	public String writeViewClassIndexCommand(String templateFile, ReferenceParser ref, String fullDescription) throws IOException {
		String template = FileUtility.readTemplate(templateFile);
		template = template.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		template = template.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mViewVariableIndex++));
		template = template.replace(Constants.VariableNames.CLASSPATH, ref.getClassName());
		template = template.replace(Constants.VariableNames.VIEW_INDEX, Integer.toString(ref.getIndex()));
		return template;
	}
	


}
