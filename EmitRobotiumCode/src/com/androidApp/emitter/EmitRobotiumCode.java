package com.androidApp.emitter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map.Entry;
import java.util.Stack;

import com.androidApp.codedefinition.CodeDefinition;
import com.androidApp.emitter.IEmitCode.LineAndTokens;
import com.androidApp.parser.ManifestParser;
import com.androidApp.parser.ProjectPropertiesScan;
import com.androidApp.savestate.SaveState;
import com.androidApp.savestate.SaveStateException;
import com.androidApp.util.AndroidUtil;
import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * @author Matthew
 * Copyright (c) 2013 Visible Automation LLC.  All Rights Reserved.
 * TODO: All Events MUST respect mLastEventWasWaitForActivity, not just click
 * TODO: add mLastEventWasCreateDialog for the same thing
 */
public class EmitRobotiumCode {
	/**
	 * take an input file spit out by the event recorder, and generate robotium code
	 * @param args 4 strings: input file (events.txt), output file test.java, target project name and the robotiumJar file.
	 * the caller has to specify the project name because the .apk file name can be changed, and it actually the name of the 
	 * build project, i.e. made from unobtainium
	 * @throws FileNotFoundException if source files can't be found
	 * @throws IOException if source files can't be read
	 * @throws EmitterException if source files can't be parsed.
	 * @throws SaveStateException if save state files can't be copied from the device.
	 */
	public static void main(String[] args) throws FileNotFoundException, IOException, EmitterException, SaveStateException {
		if (args.length < 2) {
			System.err.println("usage: EmitRobotium [events.txt|device] [view_directives.txt|device|none] <target-project-name> [binary]");
			System.err.println("events.txt is the output file from the recorder");
			System.err.println("device pulls the events.txt file from /sdcard/events.txt");
			System.err.println("<target-project-name> is the name of the project to instrument via robotium");
			System.err.println("if \"device\" is specified, then it is the class path of the activity to instrument");
			System.err.println("if <target-project-name> directory exists, then the output code will be written into");
			System.err.println("a new file with a numeric suffix, e.g. ApiDemosTest1.java");
			System.err.println("<robotium-jar-path> path to the robotium jar file (download it from http://code.google.com/p/robotium/downloads/list)");
			System.err.println("--splitFunctions splits the output into functions bracketed by activities");
			System.err.println("--minLines <min-lines> minimum # of lines of code in a function (default: 5) ");
			System.exit(-1);
		}
		String eventsFileName = args[0];
		String viewDirectiveFileName = args[1];
		String targetProject = args[2];
		String testProjectName = null;
		if (targetProject.lastIndexOf(File.separatorChar) != -1) {
			testProjectName = targetProject.substring(targetProject.lastIndexOf(File.separatorChar) + 1) + Constants.Extensions.TEST;
		} else {
			testProjectName = targetProject + Constants.Extensions.TEST;
		}
		boolean fBinary = false;
		if (args.length == 3) {
			fBinary = args[2].equals("binary");
		}
		String outputCodeFileName = Constants.Filenames.OUTPUT;
		IEmitCode emitter = null;
		if (fBinary) {
			emitter = new EmitRobotiumCodeBinary();
		} else {
			emitter = new EmitRobotiumCodeSource();
		}
		String androidSDK = System.getenv(Constants.Env.ANDROID_HOME);
		if (androidSDK == null) {
			System.err.println("The environment variable ANDROID_HOME must be set");
			System.exit(-1);
		}
		SetupRobotiumProject setup = new SetupRobotiumProject();
		SetupRobotiumProject.Options options = setup.processOptions(args);
		
		// scan the project properties file
		File binDir = new File(targetProject, Constants.Dirs.BIN);
		File apkFile = FileUtility.findFileRegexp(binDir, ".*" + Constants.Extensions.APK);
		if (apkFile == null) {
			System.err.println("unable to find APK in directory " + binDir.toString());
			System.exit(-1);
		}
		File projectPropertiesFile = new File(targetProject,  Constants.Filenames.PROJECT_PROPERTIES_FILENAME);
		ProjectPropertiesScan projectPropertiesScan = null;
		try {
			projectPropertiesScan = new ProjectPropertiesScan(projectPropertiesFile);
		} catch (Exception ex) {
			ex.printStackTrace();
			System.exit(-1);
		}
		
		// scan the project manifest
		File manifestFile = new File(targetProject, Constants.Filenames.ANDROID_MANIFEST_XML);
		ManifestParser manifestParser = null;
		try {
			manifestParser = new ManifestParser(manifestFile);
		} catch (Exception ex) {
			ex.printStackTrace();
		}

		// grab the events file
		eventsFileName = SetupRobotiumProject.getEventsFile(eventsFileName);
		if (!viewDirectiveFileName.equals(Constants.Filenames.NONE)) {
			viewDirectiveFileName = SetupRobotiumProject.getViewDirectivesFile(viewDirectiveFileName);
		}
		// TODO: we need the test class path before we can read the handlers directory, which means that
		// we need to read the events file to extract it
		// read any conditional code from the handlers directory
		Hashtable<CodeDefinition, List<LineAndTokens>> outputCode = new Hashtable<CodeDefinition, List<LineAndTokens>>();
		String applicationPackage = emitter.readApplicationPackage(eventsFileName);
		File handlersDir = new File(testProjectName, Constants.Dirs.HANDLERS);
		readHandlers(handlersDir, outputCode);
		
		// grab the  generate the test code.
		List<MotionEventList> motionEvents = new ArrayList<MotionEventList>();
		emitter.generateTestCode(eventsFileName, outputCode, motionEvents);
		List<LineAndTokens> mainCode = outputCode.get(new CodeDefinition(Constants.MAIN));
		if (emitter.getApplicationClassPath() == null) {
			System.err.println("unable to generate output code, no activity reference");
			System.exit(-1);
		}
		String testClassPath = emitter.getApplicationClassPath() + Constants.Extensions.TEST;
		int targetSDK = AndroidUtil.getBestAndroidSDKLevel(androidSDK, manifestParser.getMinSDKVersion());
		List<String> supportLibraries = FileUtility.getSupportLibraries(apkFile.getAbsolutePath());
		
		// generated test class name
		String srcDirName = testProjectName + File.separator + Constants.Dirs.SRC;
		String packageFilePath = srcDirName + File.separator + FileUtility.sourceDirectoryFromClassName(testClassPath);
		String templateFileName = testProjectName + "." + Constants.Extensions.JAVA;
		// asset directory to write motion event files to
		String assetDirName = testProjectName + File.separator + Constants.Dirs.ASSETS;
		
		// TODO: should change this variable
		int uniqueFileIndex = FileUtility.uniqueFileIndex(packageFilePath, templateFileName);
		String testClassName = testProjectName;
		if (uniqueFileIndex != 0) {
			testClassName += Integer.toString(uniqueFileIndex) ;
		}
		SetupRobotiumProject setupRobotiumProject = new SetupRobotiumProject();
		SetupRobotiumProject.Dirs dirs = setupRobotiumProject.new Dirs(testClassName, packageFilePath);

		if (emitter.getApplicationClassPath() != null) {
			
			// if no previous file was found, we're creating a project for the first time, and so we have to
			// make the directories, copy the build files, etc.  TODO:A much better test would be to check for the
			// project directory and use a flag.
			if (uniqueFileIndex == 0) {
				dirs.createDirectories();
				SetupRobotiumProject.writeBuildXML(testClassName, emitter.getApplicationClassPath());
				SetupRobotiumProject.copyBuildFiles(testClassName, projectPropertiesScan.getTarget());
				SetupRobotiumProject.copyLibraries(dirs.mLibDir, supportLibraries, manifestParser.getMinSDKVersion());
				SetupRobotiumProject.writeManifest(testProjectName, emitter.getApplicationPackage(), 
												   manifestParser.getMinSDKVersion(), Constants.Filenames.ANDROID_MANIFEST_XML);
				SetupRobotiumProject.copyTestDriverFile(packageFilePath, emitter.getApplicationClassPath() + Constants.Extensions.TEST);
				SetupRobotiumProject.writeResources(dirs, testClassName);
				if (fBinary) {
					SetupRobotiumProject.writeClasspathBinary(testClassName, Constants.Filenames.ROBOTIUM_JAR,
						    								  targetSDK, supportLibraries);
				} else {
					SetupRobotiumProject.writeClasspath(testClassName, targetProject, Constants.Filenames.ROBOTIUM_JAR,
													    targetSDK, supportLibraries);
				}
			}
		} else {
			System.err.println("no activity class specified");
		}
		
		// write the header template, the emitter output, and the trailer template.
		BufferedWriter bw = new BufferedWriter(new FileWriter(outputCodeFileName));
		emitter.writeHeader(emitter.getApplicationClassPath(), testClassPath, testClassName, emitter.getApplicationClassName(), targetSDK, supportLibraries, bw);
		if (options.mfWriteFunctions) {
			SplitFunction splitter = new SplitFunction(options.mMinLines);
			splitter.writeFunctions(bw, "test" + targetProject, 0, mainCode);
			emitter.writeClassTrailer(bw);
		} else {
			emitter.writeFunctionHeader(bw);
			emitter.writeLines(bw, mainCode);
			emitter.writeTrailer(bw);
			
			// output the function definitions
			for (Entry<CodeDefinition, List<LineAndTokens>> entry : outputCode.entrySet()) {
				CodeDefinition codeDef = entry.getKey();
				if (codeDef.getCodeType().equals(Constants.FUNCTION_DEF)) {
					List<LineAndTokens> lines = entry.getValue();
					emitter.writeLines(bw, lines);
				}
			}
			emitter.writeTrailer(bw);
		}
		
		bw.close();
		
		// save the sql, files, shared_prefs
		SaveState.saveStateFiles(androidSDK, testClassName + File.separator + Constants.Dirs.SAVESTATE, Constants.Dirs.EXTERNAL_STORAGE, emitter.getApplicationPackage());
		SetupRobotiumProject.writeMotionEvents(assetDirName, testClassName, motionEvents);
		SetupRobotiumProject.moveOutputCodeToPackage(packageFilePath, outputCodeFileName, testClassName);
		FileUtility.deleteAllFilesFromDirectory(handlersDir);
		writeConditionalCode(emitter, outputCode, handlersDir);
	}
	
	/**
	 * when the conditional code is written to a file, it is prefixed with the tokens that were read just before the
	 * "interstitial_XXX" action was read, then the code definition, then the actual code.  Read the conditional code
	 * into the code hashtable, so we can write it out again when the condition is met, and write the conditional code
	 * back to the handlers directory.
	 * @author matt2
	 *
	 */
	
	public static void readConditionalCode(InputStream 										is, 
										   Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode) throws IOException, EmitterException {
		BufferedReader br = new BufferedReader(new InputStreamReader(is));
		SuperTokenizer st = new SuperTokenizer(br.readLine(), "\"", ":,", '\\');
		List<String> tokens = st.toList();
		String codeDefCallLine = br.readLine();
		CodeDefinition codeDefCall = CodeDefinition.parse(codeDefCallLine);
		StringBuffer callCode = new StringBuffer();
		String line = br.readLine();
		while ((line != null) && !line.startsWith(Constants.FUNCTION_DEF)) {
			callCode.append(line + "\n");
			line = br.readLine();
		}
		LineAndTokens callLineAndTokens = new LineAndTokens(tokens, callCode.toString());
		List<LineAndTokens> callLineAndTokensList = new ArrayList<LineAndTokens>();
		callLineAndTokensList.add(callLineAndTokens);
		outputCode.put(codeDefCall, callLineAndTokensList);
		
		CodeDefinition codeDefDefinition = codeDefCall.makeCopy();
		codeDefDefinition.setCodeType(Constants.FUNCTION_DEF);
		StringBuffer definitionCode = new StringBuffer();
		line = br.readLine();
		while (line != null) {
			definitionCode.append(line + "\n");
			line = br.readLine();
		}
		LineAndTokens definitionLineAndTokens = new LineAndTokens(tokens, definitionCode.toString());
		List<LineAndTokens> definitionLineAndTokensList = new ArrayList<LineAndTokens>();
		definitionLineAndTokensList.add(definitionLineAndTokens);
		outputCode.put(codeDefDefinition, definitionLineAndTokensList);
	}
	
	/**
	 * write out the list of tokens used for a match, then write the condition used in the output
	 * then the output code.
	 * @param os outputstream to write to a bufferedWriter
	 * @param codeDefCall  condition to write into code
	 * @param codeCall code to execute if condition is passed.
	 * @param codeDefDefinition function definition
	 * @param codeDefinition code for function definition
	 * @throws IOException
	 * @throws EmitterException
	 */
	public static void writeConditionalCode(OutputStream			os,
										    CodeDefinition			codeDefCall,
										    List<LineAndTokens>		linesCall,
										    CodeDefinition			codeDefDefinition,
										    List<LineAndTokens>		linesDefinition) throws IOException, EmitterException {
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));
		String code = createConditionalCode(codeDefCall, linesCall, codeDefDefinition, linesDefinition);
		bw.write(code);
		bw.close();	
	}
	
	/**
	 * inner variant to create a string suitable for populating an eclipse IFile
	 * @param codeDefCall  condition to write into code
	 * @param codeCall code to execute if condition is passed.
	 * @param codeDefDefinition function definition
	 * @param codeDefinition code for function definition
	 * @return the function call, followed by the line function_def, followed by the function definition
	 * @throws IOException
	 * @throws EmitterException
	 */
	public static String createConditionalCode(CodeDefinition			codeDefCall,
											   List<LineAndTokens>		linesCall,
											   CodeDefinition			codeDefDefinition,
											   List<LineAndTokens>		linesDefinition) {
		StringBuffer sb = new StringBuffer();
		LineAndTokens scanTokensLine = linesCall.get(0);
		String scanLine = StringUtils.delimit(scanTokensLine.mTokens, ',');
		sb.append(scanLine + "\n");
		sb.append(codeDefCall.toString() + "\n");
		for (LineAndTokens codeLine : linesCall) {
			sb.append(codeLine.mOutputLine + "\n");
		}
		sb.append(Constants.FUNCTION_DEF + "\n");
		for (LineAndTokens codeLine : linesDefinition) {
			sb.append(codeLine.mOutputLine + "\n");
		}
		return sb.toString();
	}
	
	/**
	 * find the function defintion associated with this function call.
	 */
	public static CodeDefinition findFunctionDefinition(CodeDefinition codeDefTarget, Hashtable<CodeDefinition, List<LineAndTokens>> outputCode) {
		for (Entry<CodeDefinition, List<LineAndTokens>> entry : outputCode.entrySet()) {
			CodeDefinition codeDefCand = entry.getKey();
			if (codeDefCand.getCodeType().equals(Constants.FUNCTION_CALL)) {
				if (codeDefCand.getFunctionName().equals(codeDefTarget.getFunctionName())) {
					return codeDefCand;
				}
			}
		}
		return null;
	}
	/**
	 * write the conditional code out into a file, so it can be reused for later runs.
	 * if the activity is the same activity as in The Code Definition and the previous recorded
	 * token set matches (without the timestamp, obviously)
	 * @param emitter emitter to write the dialog handler
	 * @param outputCode hashtable of code output from the emitter.
	 * @param dirs dirs (which includes the dialogs directory that we put these handlers into
	 * @param testClassPath testclass so we can write the package name into the output file.
	 * @return updated Code Defintion list, with new entries added.
	 * @throws IOException
	 */
	public static void writeConditionalCode(IEmitCode 										emitter,
										    Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode,  
										    File											handlerDir) throws IOException, EmitterException {
		// write the conditional code, by activity name and unique indexed
		for (Entry<CodeDefinition, List<LineAndTokens>> entry : outputCode.entrySet()) {
			CodeDefinition codeDefCall = entry.getKey();
			List<LineAndTokens> linesCall = entry.getValue();
			if (!codeDefCall.getActivityName().equals(Constants.MAIN) && codeDefCall.getActivityName().equals(Constants.FUNCTION_DEF)) {
				CodeDefinition codeDefDefinition = CodeDefinition.findFunctionDefinition(codeDefCall, outputCode);
				List<LineAndTokens> linesDefinition = outputCode.get(codeDefDefinition);
				String templateFileName = StringUtils.getNameFromClassPath(codeDefCall.getActivityName()) + "." + Constants.Extensions.TEXT;
				int uniqueFileIndex = FileUtility.uniqueFileIndex(handlerDir, templateFileName);
				if (uniqueFileIndex != 0) {
					templateFileName += Integer.toString(uniqueFileIndex);
				}
				File file = new File(handlerDir, templateFileName);
				// when we write out the conditional code, we write the first set of tokens, because that's what we scan
				// against to insert it into the output.
				FileOutputStream fos = new FileOutputStream(file);
				writeConditionalCode(fos, codeDefCall, linesCall, codeDefDefinition, linesDefinition);
			}
		}
	}
	
	public static void readHandlers(File 											handlersDir, 
							  	   Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode) throws FileNotFoundException, EmitterException, IOException {
		if (handlersDir.exists()) {
			String[] filenames = handlersDir.list();
			for (String file : filenames) {
				FileInputStream fis = new FileInputStream(new File(handlersDir, file));
				readConditionalCode(fis, outputCode);
				fis.close();
			}
		}
	}
	
	public EmitRobotiumCode() {
	}	
}
