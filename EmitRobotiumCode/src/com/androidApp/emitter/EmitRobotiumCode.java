package com.androidApp.emitter;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map.Entry;
import java.util.Stack;

import com.androidApp.emitter.IEmitCode.LineAndTokens;
import com.androidApp.parser.ProjectPropertiesScan;
import com.androidApp.savestate.SaveState;
import com.androidApp.savestate.SaveStateException;
import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * @author Matthew
 * Copyright (c) 2013 Visible Automation LLC.  All Rights Reserved.
 * TODO: All Events MUST respect mLastEventWasWaitForActivity, not just click
 * TODO: add mLastEventWasCreateDialog for the same thing
 */
public class EmitRobotiumCode {
	/**
	 * take an input file spit out by the event recorder, and generate robotium code
	 * @param args 4 strings: input file (events.txt), output file test.java, target project name and the robotiumJar file.
	 * the caller has to specify the project name because the .apk file name can be changed, and it actually the name of the 
	 * build project, i.e. made from unobtainium
	 * @throws FileNotFoundException if source files can't be found
	 * @throws IOException if source files can't be read
	 * @throws EmitterException if source files can't be parsed.
	 * @throws SaveStateException if save state files can't be copied from the device.
	 */
	public static void main(String[] args) throws FileNotFoundException, IOException, EmitterException, SaveStateException {
		if (args.length < 2) {
			System.err.println("usage: EmitRobotium [events.txt|device] [view_directives.txt|device|none] <target-project-name> [binary]");
			System.err.println("events.txt is the output file from the recorder");
			System.err.println("device pulls the events.txt file from /sdcard/events.txt");
			System.err.println("<target-project-name> is the name of the project to instrument via robotium");
			System.err.println("if \"device\" is specified, then it is the class path of the activity to instrument");
			System.err.println("if <target-project-name> directory exists, then the output code will be written into");
			System.err.println("a new file with a numeric suffix, e.g. ApiDemosTest1.java");
			System.err.println("<robotium-jar-path> path to the robotium jar file (download it from http://code.google.com/p/robotium/downloads/list)");
			System.err.println("--splitFunctions splits the output into functions bracketed by activities");
			System.err.println("--minLines <min-lines> minimum # of lines of code in a function (default: 5) ");
			System.exit(-1);
		}
		String eventsFileName = args[0];
		String viewDirectiveFileName = args[1];
		String targetProject = args[2];
		boolean fBinary = false;
		if (args.length == 3) {
			fBinary = args[2].equals("binary");
		}
		String outputCodeFileName = Constants.Filenames.OUTPUT;
		IEmitCode emitter = null;
		if (fBinary) {
			emitter = new EmitRobotiumCodeBinary();
		} else {
			emitter = new EmitRobotiumCodeSource();
		}
		SetupRobotiumProject setup = new SetupRobotiumProject();
		SetupRobotiumProject.Options options = setup.processOptions(args);
		
		// scan the project properties file
		File projectPropertiesFile = new File(targetProject,  Constants.Filenames.PROJECT_PROPERTIES_FILENAME);
		ProjectPropertiesScan projectPropertiesScan = null;
		try {
			projectPropertiesScan = new ProjectPropertiesScan(projectPropertiesFile);
		} catch (Exception ex) {
			ex.printStackTrace();
		}

		// grab the events file
		eventsFileName = SetupRobotiumProject.getEventsFile(eventsFileName);
		if (!viewDirectiveFileName.equals(Constants.Filenames.NONE)) {
			viewDirectiveFileName = SetupRobotiumProject.getViewDirectivesFile(viewDirectiveFileName);
		}
		// TODO: we need the test class path before we can read the handlers directory, which means that
		// we need to read the events file to extract it
		// read any conditional code from the handlers directory
		Hashtable<CodeDefinition, List<LineAndTokens>> outputCode = new Hashtable<CodeDefinition, List<LineAndTokens>>();
		String applicationPackage = emitter.readApplicationPackage(eventsFileName);
		String testClassName = StringUtils.getNameFromClassPath(applicationPackage) + Constants.Extensions.TEST;
		File handlersDir = new File(testClassName, Constants.Dirs.HANDLERS);
		readHandlers(handlersDir, outputCode);
		
		// grab the  generate the test code.
		List<MotionEventList> motionEvents = new ArrayList<MotionEventList>();
		emitter.generateTestCode(eventsFileName, outputCode, motionEvents);
		List<LineAndTokens> mainCode = outputCode.get(new CodeDefinition(Constants.MAIN, null));
		if (emitter.getApplicationClassPath() == null) {
			System.err.println("unable to generate output code, no activity reference");
			System.exit(-1);
		}
		String testClassPath = emitter.getApplicationClassPath() + Constants.Extensions.TEST;
		
		// generated test class name
		String srcDirName = testClassName + File.separator + Constants.Dirs.SRC;
		String packageFilePath = srcDirName + File.separator + FileUtility.sourceDirectoryFromClassName(testClassPath);
		String templateFileName = testClassName + "." + Constants.Extensions.JAVA;
		// asset directory to write motion event files to
		String assetDirName = testClassName + File.separator + Constants.Dirs.ASSETS;
		
		// TODO: should change this variable
		int uniqueFileIndex = FileUtility.uniqueFileIndex(packageFilePath, templateFileName);
		if (uniqueFileIndex != 0) {
			testClassName += Integer.toString(uniqueFileIndex) ;
		}
		SetupRobotiumProject setupRobotiumProject = new SetupRobotiumProject();
		SetupRobotiumProject.Dirs dirs = setupRobotiumProject.new Dirs(testClassName, packageFilePath);

		if (emitter.getApplicationClassPath() != null) {
			
			// if no previous file was found, we're creating a project for the first time, and so we have to
			// make the directories, copy the build files, etc.  TODO:A much better test would be to check for the
			// project directory and use a flag.
			if (uniqueFileIndex == 0) {
				dirs.createDirectories();
				SetupRobotiumProject.writeBuildXML(testClassName, emitter.getApplicationClassPath());
				SetupRobotiumProject.copyBuildFiles(testClassName, projectPropertiesScan.getTarget());
				SetupRobotiumProject.copyLibraries(dirs.mLibDir);
				SetupRobotiumProject.writeManifest(testClassName, testClassName, testClassPath, emitter.getApplicationPackage());
				SetupRobotiumProject.copyTestDriverFile(packageFilePath, emitter.getApplicationClassPath() + Constants.Extensions.TEST);
				SetupRobotiumProject.writeResources(dirs, testClassName);
				if (fBinary) {
					SetupRobotiumProject.writeClasspathBinary(testClassName, Constants.Filenames.ROBOTIUM_JAR);
				} else {
					SetupRobotiumProject.writeClasspath(testClassName, targetProject, Constants.Filenames.ROBOTIUM_JAR);
				}
			}
		} else {
			System.err.println("no activity class specified");
		}
		
		// write the header template, the emitter output, and the trailer template.
		BufferedWriter bw = new BufferedWriter(new FileWriter(outputCodeFileName));
		emitter.writeHeader(emitter.getApplicationClassPath(), testClassPath, testClassName, emitter.getApplicationClassName(), bw);
		if (options.mfWriteFunctions) {
			SplitFunction splitter = new SplitFunction(options.mMinLines);
			splitter.writeFunctions(bw, "test" + targetProject, 0, mainCode);
			emitter.writeClassTrailer(bw);
		} else {
			emitter.writeFunctionHeader(bw);
			emitter.writeLines(bw, mainCode);
			emitter.writeTrailer(bw);
		}
		
		bw.close();
		String androidSDK = System.getenv(Constants.Env.ANDROID_HOME);
		
		// save the sql, files, shared_prefs
		SaveState.saveStateFiles(androidSDK, testClassName + File.separator + Constants.Dirs.SAVESTATE, Constants.Dirs.EXTERNAL_STORAGE, emitter.getApplicationPackage());
		SetupRobotiumProject.writeMotionEvents(assetDirName, testClassName, motionEvents);
		SetupRobotiumProject.moveOutputCodeToPackage(packageFilePath, outputCodeFileName, testClassName);
		FileUtility.deleteAllFilesFromDirectory(handlersDir);
		writeConditionalCode(emitter, outputCode, handlersDir);
	}
	
	/**
	 * when the conditional code is written to a file, it is prefixed with the tokens that were read just before the
	 * "interstitial_XXX" action was read, then the code definition, then the actual code.  Read the conditional code
	 * into the code hashtable, so we can write it out again when the condition is met, and write the conditional code
	 * back to the handlers directory.
	 * @author matt2
	 *
	 */
	
	public static void readConditionalCode(InputStream 										is, 
										   Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode) throws IOException, EmitterException {
		BufferedReader br = new BufferedReader(new InputStreamReader(is));
		SuperTokenizer st = new SuperTokenizer(br.readLine(), "\"", ":,", '\\');
		List<String> tokens = st.toList();
		String codeDefLine = br.readLine();
		CodeDefinition codeDef = CodeDefinition.parse(codeDefLine);
		StringBuffer code = new StringBuffer();
		String line = br.readLine();
		while (line != null) {
			code.append(line);
			line = br.readLine();
		}
		LineAndTokens lineAndTokens = new LineAndTokens(tokens, line);
		List<LineAndTokens> lineAndTokensList = new ArrayList<LineAndTokens>();
		lineAndTokensList.add(lineAndTokens);
		outputCode.put(codeDef, lineAndTokensList);
	}
	
	/**
	 * write out the list of tokens used for a match, then write the condition used in the output
	 * then the output code.
	 * @param os outputstream to write to a bufferedWriter
	 * @param codeDef condition to write into code
	 * @param code code to execute if condition is passed.
	 * @throws IOException
	 * @throws EmitterException
	 */
	public static void writeConditionalCode(OutputStream			os,
										    CodeDefinition			codeDef,
										    List<LineAndTokens>		code) throws IOException, EmitterException {
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));
		LineAndTokens scanTokensLine = code.get(0);
		String scanLine = StringUtils.delimit(scanTokensLine.mTokens, ',');
		bw.write(scanLine + "\n");
		bw.write(codeDef.toString() + "\n");
		for (LineAndTokens codeLine : code) {
			bw.write(codeLine.mOutputLine + "\n");
		}
		bw.close();	
	}
	
	/**
	 * write the conditional code out into a file, so it can be reused for later runs.
	 * if the activity is the same activity as in The Code Definition and the previous recorded
	 * token set matches (without the timestamp, obviously)
	 * @param emitter emitter to write the dialog handler
	 * @param outputCode hashtable of code output from the emitter.
	 * @param dirs dirs (which includes the dialogs directory that we put these handlers into
	 * @param testClassPath testclass so we can write the package name into the output file.
	 * @return updated Code Defintion list, with new entries added.
	 * @throws IOException
	 */
	public static void writeConditionalCode(IEmitCode 										emitter,
										    Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode,  
										    File											handlerDir) throws IOException, EmitterException {
		// write the conditional code, by activity name and unique indexed
		for (Entry<CodeDefinition, List<LineAndTokens>> entry : outputCode.entrySet()) {
			CodeDefinition codeDef = entry.getKey();
			List<LineAndTokens> code = entry.getValue();
			if (!codeDef.getActivityName().equals(Constants.MAIN)) {
				String templateFileName = codeDef.getActivityName();
				int uniqueFileIndex = FileUtility.uniqueFileIndex(handlerDir, templateFileName);
				if (uniqueFileIndex != 0) {
					templateFileName += Integer.toString(uniqueFileIndex);
				}
				templateFileName += "." + Constants.Extensions.TEXT;
				File file = new File(handlerDir, templateFileName);
				// when we write out the conditional code, we write the first set of tokens, because that's what we scan
				// against to insert it into the output.
				FileOutputStream fos = new FileOutputStream(file);
				writeConditionalCode(fos, codeDef, code);
			}
		}
	}
	
	public static void readHandlers(File 											handlersDir, 
							  	   Hashtable<CodeDefinition, List<LineAndTokens>> 	outputCode) throws FileNotFoundException, EmitterException, IOException {
		if (handlersDir.exists()) {
			String[] filenames = handlersDir.list();
			for (String file : filenames) {
				FileInputStream fis = new FileInputStream(new File(handlersDir, file));
				readConditionalCode(fis, outputCode);
				fis.close();
			}
		}
	}
	
	public EmitRobotiumCode() {
	}	
}
