package com.androidApp.emitter;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;

/**
 * class to split lines of robotium code into functions based on the depth of the activity stack
 * Copyright (c) 2013 Visible Automation LLC.  All Rights Reserved.
 */
public class SplitFunction {
	protected ClassTable mClassTable;				// symbol table for function to reduce repeated references
	protected int		 mMinLines;					// minimum # of lines for code to be broken into a subfunction
	
	
	protected class FunctionIndex {
		String 	mFunctionName;
		int		mStartIndex;
		
		public FunctionIndex(String functionName, int startIndex) {
			mFunctionName = functionName;
			mStartIndex = startIndex;
		}
	}
	
	public SplitFunction(int minLines) {
		mClassTable = new ClassTable();
		mMinLines = minLines;
	}
	
	public SplitFunction(ClassTable classTable, int minLines) {
		mClassTable = classTable;
		mMinLines = minLines;
	}
	
	/**
	 * retreive a unique function name from the activity class extracted from the waitForActivity() call
	 * @param lineAndTokens output line and source tokens
	 * @return unique function name based on the activity class
	 */
	public String getFunctionName(EmitRobotiumCodeSource.LineAndTokens lineAndTokens) {
		String activityName = lineAndTokens.mTokens.get(2);
		String functionName = mClassTable.getVariableName(activityName);
		return functionName;
	}
	
	/**
	 * write the function header from the waitForActivity() line
	 * @param bw
	 * @param lineAndTokens
	 * @throws IOException
	 */
	public void writeFunctionHeader(BufferedWriter bw, String functionName, EmitRobotiumCodeSource.LineAndTokens lineAndTokens) throws IOException {
		String functionHeader = FileUtility.readTemplate(Constants.Templates.FUNCTION_HEADER);
		functionHeader = functionHeader.replace(Constants.VariableNames.FUNCTION_NAME, functionName);
		bw.write(functionHeader);
	}
	
	/**
	 * write the function call from the waitForActivity() line
	 * @param bw
	 * @param functionName
	 * @param lineAndTokens
	 * @throws IOException
	 */
	public void writeFunctionCall(BufferedWriter bw, String functionName, EmitRobotiumCodeSource.LineAndTokens lineAndTokens) throws IOException {
		String functionCall = FileUtility.readTemplate(Constants.Templates.FUNCTION_CALL);
		functionCall = functionCall.replace(Constants.VariableNames.FUNCTION_NAME, functionName);
		bw.write(functionCall);
	}

	
	/**
	 * write the close of a function.
	 * @param bw
	 * @throws IOException
	 */
	public static void writeFunctionTrailer(BufferedWriter bw) throws IOException {
		String functionTrailer = FileUtility.readTemplate(Constants.Templates.FUNCTION_TRAILER);
		bw.write(functionTrailer);	
	}
	
	// take the raw lines of data generated by EmitRobotimCode, and break it up into functions bracketed by
	// waitForActivity() and goBack()
	public void writeFunctions(BufferedWriter bw, 
							   String functionName, 
							   int startIndex, 
							   List<EmitRobotiumCodeSource.LineAndTokens> lines) throws IOException {
		List<FunctionIndex> nestedFunctions = new ArrayList<FunctionIndex>();
		int depth = 0;
		boolean fFoundStart = false;
		for (int index = startIndex; index < lines.size(); index++) {
			EmitRobotiumCodeSource.LineAndTokens line = lines.get(index);
			boolean fLineIsInCalledFunction = false;
			if (line.mOutputLine.contains(Constants.SoloFunctions.WAIT_FOR_ACTIVITY)) {
				if (fFoundStart) {
					depth++;
					if (depth == 2) {
						// assign first so declaration and call get the same name
						String localFunctionName  = getFunctionName(line);
						FunctionIndex functionIndex = new SplitFunction(mClassTable, mMinLines).new FunctionIndex(localFunctionName, index);
						nestedFunctions.add(functionIndex);
						writeFunctionCall(bw, localFunctionName, line);
					}
				} else {
					writeFunctionHeader(bw, functionName, line);
					depth++;
					fFoundStart = true;
				}
			} else if (line.mOutputLine.contains(Constants.SoloFunctions.GO_BACK)) {
				depth--;
				if (depth == 0) {
					bw.write(line.mOutputLine);
					break;
				} else if (depth == 1) {
					fLineIsInCalledFunction = true;
				}
			}
			if ((depth == 1) && !fLineIsInCalledFunction) {
				bw.write(line.mOutputLine);
			}		
		}
		writeFunctionTrailer(bw);
		// recurse through all the functions that we found
		for (Iterator<FunctionIndex> lineIter = nestedFunctions.iterator(); lineIter.hasNext();) {
			FunctionIndex functionIndex = lineIter.next();
			SplitFunction splitter = new SplitFunction(mClassTable, mMinLines);
			splitter.writeFunctions(bw, functionIndex.mFunctionName, functionIndex.mStartIndex, lines);
		}
	}
}
