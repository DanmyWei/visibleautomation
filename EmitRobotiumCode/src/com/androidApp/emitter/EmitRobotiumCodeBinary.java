package com.androidApp.emitter;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.List;

import com.androidApp.emitter.IEmitCode.LineAndTokens;
import com.androidApp.util.Constants;
import com.androidApp.util.FileUtility;
import com.androidApp.util.StringUtils;
import com.androidApp.util.SuperTokenizer;

/** 
 * class to emit robotium code from the events.txt file generated by the recorder.
 * Variant for binary applications: changes header, initialization and test function
 * @author Matthew
 * Copyright (c) 2013 Visible Automation LLC.  All Rights Reserved.
 * binary variant of EmitRobotiumCode, uses Class.forName() for all activity references.
 */
public class EmitRobotiumCodeBinary extends EmitRobotiumCodeSource {
	
	/**
	 * write the header on the first activity (binary APK case
	 * @param testPackage com.package.name for the test application
	 * @param testClassName classNameTest<index>
	 * @param className name of the test application
	 * @param bw output BufferedWriter
	 * @throws IOException
	 */
	public void writeHeader(String 			classPath, 
						    String 			testPackage, 
						    String 			testClassName, 
						    String 			className, 
						    BufferedWriter 	bw) throws IOException {
		String header = FileUtility.readTemplate(Constants.Templates.BINARY_HEADER);
		header = header.replace(Constants.VariableNames.TESTPACKAGE, testPackage);
		header = header.replace(Constants.VariableNames.CLASSPATH, classPath);
		header = header.replace(Constants.VariableNames.CLASSNAME, className);
		header = header.replace(Constants.VariableNames.TESTCLASSNAME, testClassName);
		bw.write(header);
	}
	
	/**
	 * write the activity handlers
	 * @param handlerNames names of the handler classes
	 * @param activityNames names of the activities that they are registered for
	 * @return string to insert into the header.txt file
	 */
	public String writeActivityHandlers(List<String> handlerNames, List<String> activityNames) throws IOException {
		StringBuffer sbHandlerList = new StringBuffer();
		for (int i = 0; i < handlerNames.size(); i++) {
			String handlerExpr = FileUtility.readTemplate(Constants.Templates.ACTIIVTY_HANDLER_BINARY);
			String handler = handlerNames.get(i);
			String activity = activityNames.get(i);	
			handlerExpr = handlerExpr.replace(Constants.VariableNames.HANDLER, handler);
			handlerExpr = handlerExpr.replace(Constants.VariableNames.ACTIVITY, activity);
			sbHandlerList.append(handlerExpr);
		}
		return sbHandlerList.toString();			
	}
	
	/**
	 * write the test function header
	 * @param bw output writer
	 * @throws IOException if the function header template can't be read
	 */
	public void writeFunctionHeader(BufferedWriter bw) throws IOException {
		String testFunction = FileUtility.readTemplate(Constants.Templates.BINARY_TEST_FUNCTION);
		bw.write(testFunction);
	}

	/**
	 * when we go back to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWentBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.BINARY_WENT_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	/**
	 * the application has finished an activity, or set of activities, so we just need to wait for the activity.
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackToMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.BINARY_GO_BACK_TO_MATCHING_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}

	/**
	 * solo.waitForActivity() when we go forward or back to an activity
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.BINARY_WAIT_FOR_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	/**
	 * when we go forward to an activity of the same name as the current one, we get the current activity
	 * variable, then save it, and wait for another activity of the same name to come into existence
	 * which is different from that variable
	 * @param nextActivityVariable name of the activity variable we saved
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */

	public void writeWaitForMatchingActivity(String nextActivityVariable, List<String> tokens, List<LineAndTokens> lines) throws IOException {
		String waitTemplate = FileUtility.readTemplate(Constants.Templates.BINARY_WAIT_FOR_NEW_ACTIVITY);
		String classPath = tokens.get(2);
		String description = getDescription(tokens);
		String fullDescription = "wait for activity " + description;
		waitTemplate = waitTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.ACTIVITY, nextActivityVariable);
		waitTemplate = waitTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		mActivityVariableIndex++;
		lines.add(new LineAndTokens(tokens, waitTemplate));
	}
	
	/**
	 * write the solo.goBack() call
	 * @param tokens parsed from a line in events.txt
	 * @param lines output list of java instructions
	 * @throws IOException if the template file can't be read
	 */
	public void writeGoBackAndWaitForActivity(List<String> tokens, List<LineAndTokens> lines) throws IOException {
		if (tokens.size() > 2) {
			String classPath = tokens.get(2);
			String description = getDescription(tokens);
			String fullDescription = "wait for activity " + description;
			String goBackTemplate = FileUtility.readTemplate(Constants.Templates.BINARY_GO_BACK_WAIT_ACTIVITY);
			goBackTemplate = goBackTemplate.replace(Constants.VariableNames.DESCRIPTION, fullDescription);
			goBackTemplate = goBackTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, classPath);
			lines.add(new LineAndTokens(tokens, goBackTemplate));
		} else {
			String goBackTemplate = FileUtility.readTemplate(Constants.Templates.GO_BACK);
			lines.add(new LineAndTokens(tokens, goBackTemplate));			
		}
	}
	
	LineAndTokens activityConditionBinary(List<String> tokens, String activityName) throws IOException {
		String dialogConditionTemplate = FileUtility.readTemplate(Constants.Templates.ACTIVITY_CONDITION_BINARY);
		String description = "wait to see if activity " + activityName + " has appeared";
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.ACTIVITY_CLASS, activityName);
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		return new LineAndTokens(tokens, dialogConditionTemplate);
	}
	
	
	/**
	 * write out the conditional test for a dialog.
	 * @param tokens
	 * @param codeDef
	 * @return
	 * @throws IOException
	 */
	LineAndTokens dialogCondition(List<String> tokens, CodeDefinition codeDef) throws IOException {
		String dialogConditionTemplate = FileUtility.readTemplate(Constants.Templates.DIALOG_CONDITION_BINARY);
		String description = "wait to see if a dialog with string " + codeDef.getDialogTag() + " has appeared";
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.DESCRIPTION, description);
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.VARIABLE_INDEX, Integer.toString(mActivityVariableIndex));
		dialogConditionTemplate = dialogConditionTemplate.replace(Constants.VariableNames.CODE_DEFINITION, codeDef.toCode());
		mActivityVariableIndex++;
		return new LineAndTokens(tokens, dialogConditionTemplate);
	}


}
